{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySpring Framework","text":""},{"location":"#overview","title":"Overview","text":"<p>PySpring is a Python web framework inspired by Spring Boot. It provides a structured approach to building scalable web applications with key features like:</p> <ul> <li>Auto Dependency Injection</li> <li>Auto Configuration Management</li> <li>ASGI Web Server for hosting your application</li> </ul>"},{"location":"#technologies-used-in-pyspring","title":"Technologies Used in PySpring","text":"<ul> <li>FastAPI: For the web server layer.</li> <li>Pydantic: For data validation.</li> </ul> <p>PySpring combines these technologies to deliver a seamless development experience for building modern, scalable applications.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Application Initialization: PySpringApplication class serves as the main entry point for the PySpring application. It initializes the application from a configuration file, scans the application source directory for Python files, and groups them into class files and model files</p> </li> <li> <p>Application Context Management: PySpring manages the application context and dependency injection. It registers application entities such as components, controllers, bean collections, and properties. It also initializes the application context and injects dependencies.</p> </li> <li> <p>REST Controllers: PySpring supports RESTful API development using the RestController class. It allows you to define routes, handle HTTP requests, and register middlewares easily.</p> </li> <li> <p>Component-based Architecture: PySpring encourages a component-based architecture, where components are reusable and modular building blocks of the application. Components can have their own lifecycle and can be registered and managed by the application context.</p> </li> <li> <p>Properties Management: Properties classes provide a convenient way to manage application-specific configurations. PySpring supports loading properties from a properties file and injecting them into components.</p> </li> <li> <p>Framework Modules: PySpring allows the integration of additional framework modules to extend the functionality of the application. Modules can provide additional routes, middlewares, or any other custom functionality required by the application.</p> </li> <li> <p>Builtin FastAPI Integration: PySpring integrates with <code>FastAPI</code>, a modern, fast (high-performance), web framework for building APIs with Python. It leverages FastAPI's features for routing, request handling, and server configuration.</p> </li> <li> <p>OpenAPI Generation: Since PySpring leverages <code>FastAPI</code>, it automatically generates OpenAPI documentation for the application. The API routes, endpoints, and data models are used to create interactive, self-updating OpenAPI documentation, which can be easily accessed via FastAPI's built-in web interface.</p> </li> <li> <p>Type-Safety: The framework is type-safe when used properly. All dependency injection (DI) is determined based on Python type hints, ensuring that dependencies are injected in a consistent and reliable manner. This feature enables better development practices by reducing runtime errors and improving code clarity.</p> </li> <li> <p>Qualifier Support: PySpring supports qualifiers for dependency injection, allowing you to specify which implementation to inject when multiple implementations of the same interface exist. This is achieved using Python's <code>Annotated</code> type hints, making it easy to manage complex dependency scenarios.</p> </li> <li> <p>Component Registration Validation: The framework includes robust validation to prevent duplicate component registration and provides clear error messages for developers. This ensures that your application maintains a clean and consistent component structure.</p> </li> <li> <p>Decorator-Based Route Mapping: PySpring now supports a more declarative approach to route definition using decorators, similar to Spring's annotation-based routing. This provides a cleaner and more type-safe way to define API endpoints with better IDE support and code organization.</p> </li> <li> <p>Event System: PySpring provides a powerful event system that enables event-driven architecture in your applications. It features thread-safe event publishing, decorator-based event listeners, and asynchronous event processing. The system is fully integrated with the component system and provides type-safe events using Pydantic models.</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with PySpring, follow these steps:</p> <ol> <li>Install the PySpring framework by running:</li> </ol> <pre><code>pip3 install py-spring-core\n</code></pre> <ol> <li> <p>Create a new Python project and navigate to its directory</p> </li> <li> <p>Implement your application properties, components, controllers, using PySpring conventions inside declared source code folder (whcih can be modified the key <code>app_src_target_dir</code> inside app-config.json), this controls what folder will be scanned by the framework.</p> </li> <li> <p>Instantiate a <code>PySpringApplication</code> object in your main script, passing the path to your application configuration file.</p> </li> <li> <p>Optionally, define and enable any framework modules you want to use.</p> </li> <li> <p>Run the application by calling the <code>run()</code> method on the <code>PySpringApplication</code> object, as shown in the example code below:</p> </li> </ol> <pre><code>from py_spring_core import PySpringApplication\n\ndef main():\n    app = PySpringApplication(\"./app-config.json\")\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li>For example project, please refer to this github repo.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to PySpring are welcome! If you find any issues or have suggestions for improvements, please submit a pull request or open an issue on GitHub.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/","title":"Dependency Injection with Entities in PySpring","text":"<p>PySpring's dependency injection (DI) system simplifies dependency management, improves code modularity, and promotes loose coupling between application entities. This guide covers how to use PySpring's DI system to integrate components and other application entities.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#key-features-of-pysprings-di-system","title":"Key Features of PySpring's DI System","text":""},{"location":"guide/dependency-injection/auto-deppendency-injection/#1-declaring-dependencies","title":"1. Declaring Dependencies","text":"<p>To inject a dependency into a component, declare an attribute with a type hint for the required dependency. PySpring automatically resolves and injects the required dependency during application initialization.</p> <p>Example:</p> <pre><code>from py_spring_core import Component\nclass ExampleService(Component):\n    example_properties: ExampleProperties\n</code></pre> <p>Here, the <code>ExampleService</code> component declares a dependency on <code>ExampleProperties</code> by defining the <code>example_properties</code> attribute with the appropriate type annotation.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#2-automatic-resolution","title":"2. Automatic Resolution","text":"<p>During initialization, PySpring's <code>ApplicationContext</code> automatically scans declared dependencies, resolves them, and injects the corresponding instances.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#how-it-works","title":"How It Works:","text":"<ul> <li> <p>When a component is instantiated, the <code>_inject_entity_dependencies</code> method of the <code>ApplicationContext</code> is called.</p> </li> <li> <p>If the dependency is a <code>Properties</code> class, the system retrieves the properties from the application context using the key defined in the <code>Properties</code> class.</p> </li> <li> <p>If the dependency is not a <code>Properties</code> class, the system retrieves it from the component or bean collection using <code>get_component</code> or <code>get_bean</code>.</p> </li> <li> <p>If the dependency cannot be resolved, an error is raised.</p> </li> </ul> <p>Error Handling: If a dependency cannot be resolved, <code>_inject_entity_dependencies</code> raises a <code>ValueError</code> with a descriptive error message. This ensures early detection of misconfigured dependencies.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#3-accessing-injected-dependencies","title":"3. Accessing Injected Dependencies","text":"<p>Once injected, dependencies can be accessed directly using the declared attribute name.</p> <p>Example:</p> <pre><code>from py_spring_core import Component\nclass ExampleService(Component):\n    example_properties: ExampleProperties\n\n    def display_property(self):\n        print(self.example_properties.value)\n</code></pre> <p>Here, <code>example_properties</code> is automatically injected, and its value is accessed using <code>self.example_properties.value</code>.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#4-component-lifecycle-methods","title":"4. Component Lifecycle Methods","text":"<p>PySpring supports lifecycle methods to manage component behavior:</p> <ul> <li> <p><code>post_construct()</code>: Called after dependencies are injected, allowing initialization with injected resources.</p> </li> <li> <p><code>pre_destroy()</code>: Called before the component is destroyed, enabling cleanup actions.</p> </li> </ul> <p>Example:</p> <pre><code>class ExampleService(Component):\n    example_properties: ExampleProperties\n\n    def post_construct(self):\n        print(\"Component initialized with\", self.example_properties)\n\n    def pre_destroy(self):\n        print(\"Cleaning up ExampleService\")\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#5-supported-dependency-types","title":"5. Supported Dependency Types","text":"<p>PySpring's DI system supports injecting the following:</p> <ul> <li> <p>Component classes</p> </li> <li> <p>Properties classes</p> </li> <li> <p>Beans defined within a <code>BeanCollection</code></p> </li> </ul>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#6-qualifier-support","title":"6. Qualifier Support","text":"<p>PySpring supports qualifiers for dependency injection, allowing you to specify which implementation to inject when multiple implementations of the same interface exist.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#using-qualifiers","title":"Using Qualifiers:","text":"<pre><code>from typing import Annotated\nfrom py_spring_core import Component\n\nclass ServiceConsumer(Component):\n    # Will inject the specifically qualified implementation\n    service_a: Annotated[AbstractService, \"ServiceA\"]\n    service_b: Annotated[AbstractService, \"ServiceB\"]\n\n    def post_construct(self) -&gt; None:\n        print(self.service_a.process())  # Uses ServiceA\n        print(self.service_b.process())  # Uses ServiceB\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#complete-example-with-qualifiers","title":"Complete Example with Qualifiers:","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Annotated\nfrom py_spring_core import Component\nfrom py_spring_core.core.entities.component import ComponentScope\n\n# Abstract base class\nclass AbstractExample(Component, ABC):\n    class Config:\n        scope = ComponentScope.Singleton\n\n    @abstractmethod\n    def say_hello(self) -&gt; str: ...\n\n# First implementation\nclass ExampleA(AbstractExample):\n    class Config:\n        name = \"ExampleA\"\n        scope = ComponentScope.Singleton\n\n    def say_hello(self) -&gt; str:\n        return \"Hello from Example A!\"\n\n# Second implementation\nclass ExampleB(AbstractExample):\n    class Config:\n        name = \"ExampleB\"\n        scope = ComponentScope.Singleton\n\n    def say_hello(self) -&gt; str:\n        return \"Hello from Example B!\"\n\n# Service using both implementations\nclass TestService(Component):\n    example_a: Annotated[AbstractExample, \"ExampleA\"]\n    example_b: Annotated[AbstractExample, \"ExampleB\"]\n\n    def post_construct(self) -&gt; None:\n        print(self.example_a.say_hello())  # Output: \"Hello from Example A!\"\n        print(self.example_b.say_hello())  # Output: \"Hello from Example B!\"\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#7-component-registration-validation","title":"7. Component Registration Validation","text":"<p>PySpring now includes validation to prevent duplicate component registration and provides clear error messages for developers.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#preventing-duplicate-registration","title":"Preventing Duplicate Registration:","text":"<pre><code>from py_spring_core import Component\nfrom py_spring_core.core.entities.component import ComponentScope\n\n# First registration of MyService\nclass MyService(Component):\n    class Config:\n        name = \"MyService\"\n        scope = ComponentScope.Singleton\n\n    def do_something(self) -&gt; str:\n        return \"Service is working!\"\n\n# Attempting to register the same component again will raise ValueError\ntry:\n    class MyService(Component):  # This will raise ValueError\n        class Config:\n            name = \"MyService\"\n            scope = ComponentScope.Singleton\n\n        def do_something(self) -&gt; str:\n            return \"This will never be registered!\"\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Output: \"Error: [COMPONENT REGISTRATION ERROR] Component: MyService already registered\"\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#key-points-for-component-registration","title":"Key Points for Component Registration:","text":"<ol> <li>Each component must have a unique name (either explicitly set in Config or derived from the class name)</li> <li>Attempting to register a component with an existing name will raise a ValueError</li> <li>The name in Config can be used to override the default class name</li> <li>All components must have a valid implementation of any abstract methods they inherit</li> </ol>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#practical-example","title":"Practical Example","text":"<p>Below is an example showcasing the DI system in action:</p> <pre><code>from py_spring_core import Component, Properties\nclass ExampleProperties(Properties):\n    key: str\n    value: str\n\nclass ExampleService(Component):\n    example_properties: ExampleProperties\n\n    def post_construct(self):\n        print(f\"Initialized with property: {self.example_properties.value}\")\n\n    def pre_destroy(self):\n        print(\"ExampleService is being cleaned up\")\n\nclass AnotherExampleService(Component):\n    example_service: ExampleService\n\n    def post_construct(self):\n        print(\"AnotherExampleService initialized\")\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#steps-in-dependency-injection","title":"Steps in Dependency Injection:","text":"<ol> <li> <p>Load Properties: <code>ExampleProperties</code> values are loaded from the application's properties file.</p> </li> <li> <p>Component Instantiation: An instance of <code>ExampleService</code> is created.</p> </li> <li> <p>Dependency Injection: The <code>example_properties</code> attribute of <code>ExampleService</code> is injected with the <code>ExampleProperties</code> instance.</p> </li> <li> <p>Another Component Instantiation: An instance of <code>AnotherExampleService</code> is created.</p> </li> <li> <p>Cross-Component Injection: The <code>example_service</code> attribute of <code>AnotherExampleService</code> is injected with the <code>ExampleService</code> instance.</p> </li> <li> <p>Lifecycle Methods: <code>post_construct</code> methods are called for both components.</p> </li> <li> <p>Cleanup: On application shutdown, the <code>pre_destroy</code> method of <code>ExampleService</code> is called.</p> </li> </ol>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#summary","title":"Summary","text":"<p>PySpring's DI system provides:</p> <ul> <li> <p>Seamless Dependency Management: Automatically resolves and injects dependencies.</p> </li> <li> <p>Error Handling: Ensures misconfigurations are detected early.</p> </li> <li> <p>Lifecycle Support: Enables initialization and cleanup logic.</p> </li> <li> <p>Flexibility: Supports a wide range of dependency types, including components, properties, and beans.</p> </li> </ul> <p>By simply declaring dependencies using type hints, PySpring handles the resolution and injection, letting you focus on building modular, testable, and maintainable applications.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/","title":"Dependency Injection (DI)","text":"<p>Dependency Injection (DI) is a design pattern and a fundamental concept in software engineering. It is a technique where an object (or function) receives its dependencies from an external source rather than creating them itself. This approach promotes loose coupling between components, making the code more modular, testable, and maintainable.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#core-concepts","title":"Core Concepts","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-dependency","title":"1. Dependency","text":"<p>A dependency is any object or service that another object requires to function. For example, a <code>Service</code> class might rely on a <code>Repository</code> class to fetch data.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-injection","title":"2. Injection","text":"<p>Injection refers to the process of providing the dependency to the object that needs it. This is usually handled by a DI container or framework.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#types-of-dependency-injection","title":"Types of Dependency Injection","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-constructor-injection","title":"1. Constructor Injection","text":"<p>Dependencies are provided through the constructor of the dependent class.</p> <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service(repo)\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-setter-injection","title":"2. Setter Injection","text":"<p>Dependencies are provided through a setter method after the object is constructed. <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def set_repository(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service()\nservice.set_repository(repo)\nprint(service.get_data())\n</code></pre></p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#benefits-of-dependency-injection","title":"Benefits of Dependency Injection","text":"<ul> <li> <p>Loose Coupling: Classes are decoupled from their dependencies, making them easier to modify and extend.</p> </li> <li> <p>Improved Testability: Dependencies can be replaced with mock objects, facilitating unit testing.</p> </li> <li> <p>Easier Maintenance: Changes to a dependency's implementation do not affect the dependent classes.</p> </li> <li> <p>Reusability: Components are more reusable because they do not rely on specific implementations.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#challenges-without-dependency-injection","title":"Challenges Without Dependency Injection","text":"<p>Without DI, objects are responsible for creating their own dependencies, which can lead to several issues:</p> <ul> <li> <p>Tight Coupling Classes directly instantiate their dependencies, making them tightly coupled. This means any change in the dependency's implementation requires changes in the dependent class.</p> </li> <li> <p>Reduced Testability Since dependencies are hard-coded, it becomes challenging to replace them with mock objects during testing, complicating unit testing efforts.</p> </li> <li> <p>Limited Reusability Components become less reusable because they are bound to specific implementations rather than abstractions.</p> </li> <li> <p>Complex Maintenance With dependencies directly embedded, managing and updating dependencies becomes more difficult, leading to potential code duplication and increased maintenance overhead.</p> </li> <li> <p>Violation of the Single Responsibility Principle When classes manage their own dependencies, they take on additional responsibilities beyond their primary purpose, violating the Single Responsibility Principle and reducing code clarity.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#example-without-dependency-injection","title":"Example Without Dependency Injection","text":"<pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self):\n        # Directly creating the dependency inside the class\n        self.repository = Repository()\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\n# Usage\nservice = Service()\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#problems-in-the-code","title":"Problems in the Code","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-tight-coupling","title":"1. Tight Coupling","text":"<ul> <li>The <code>Service</code> class directly creates an instance of the <code>Repository</code> class in its constructor. This means the <code>Service</code> class is tightly coupled to the <code>Repository</code> class.</li> <li>If you wanted to change the data source, for example, switching from a <code>Repository</code> to an <code>ApiRepository</code>, you would need to modify the <code>Service</code> class. This breaks the principle of loose coupling.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-reduced-testability","title":"2. Reduced Testability","text":"<ul> <li>In this setup, unit testing becomes difficult because we can't replace the <code>Repository</code> with a mock or a stub.</li> <li>The <code>Service</code> class always depends on a real instance of the <code>Repository</code> class, making tests harder to isolate and slower to run.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#3-limited-reusability","title":"3. Limited Reusability","text":"<ul> <li>The <code>Service</code> class is not reusable with different kinds of repositories. </li> <li>If you wanted to use the <code>Service</code> class with a different repository implementation, you'd have to modify the <code>Service</code> class itself. This is not flexible and goes against the idea of creating reusable components.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#4-complex-maintenance","title":"4. Complex Maintenance","text":"<ul> <li>As the application grows and more dependencies are added to the <code>Service</code> class, it becomes more difficult to manage.</li> <li>If every class is responsible for creating its own dependencies, the codebase becomes harder to maintain, leading to potential code duplication and tightly coupled components.</li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/","title":"Bean Collection","text":"<p>The <code>BeanCollection</code> class in PySpring is designed to help integrate third-party code, especially when developers cannot modify the code directly. Below is a breakdown of its key features and functionality.</p>"},{"location":"guide/entities-in-framework/bean-collection/#purpose-and-key-features","title":"Purpose and Key Features","text":"<ul> <li> <p>Bean Management: The <code>BeanCollection</code> helps organize and manage a collection of beans (components) within a class. It provides a way to access and control these beans efficiently.</p> </li> <li> <p>Scanning for Beans: The <code>scan_beans()</code> method scans the current class for methods that create beans. These methods are identified by their names, which by default start with the identifier <code>create</code> (e.g., <code>createMyBean</code>).</p> </li> <li> <p>Bean Creation: Beans are created using methods whose return types are annotated. The return type of a bean creation method indicates the type of the bean being created.</p> </li> <li> <p>BeanView: Each bean is represented by a <code>BeanView</code> object, which holds:</p> <ul> <li>The bean itself</li> <li>The bean's name</li> <li>The bean creation function</li> <li>A validation method (<code>is_valid_bean()</code>) to check if the bean's name matches the name of the class it returns.</li> <li>Error Handling: Common errors are handled through exceptions, such as:<ul> <li><code>BeanConflictError</code>: Raised when a bean with the same name already exists.</li> <li><code>InvalidBeanError</code>: Raised when the bean's name doesn't match the class name.</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#properties-integration","title":"Properties Integration","text":"<p><code>BeanCollection</code> can also work with properties, which are loaded before the beans are created. This is a key aspect of how <code>BeanCollection</code> integrates with the broader PySpring framework.</p>"},{"location":"guide/entities-in-framework/bean-collection/#how-properties-interact-with-beancollection","title":"How Properties Interact with BeanCollection:","text":"<ul> <li> <p>Properties Loading:     PySpring loads properties from a designated properties file using the <code>Properties</code> class and <code>_PropertiesLoader</code>. This happens before the initialization of the Inversion of Control (IoC) container.</p> </li> <li> <p>Accessing Properties:     Once loaded, properties are accessible via the <code>get_properties()</code> method in the <code>ApplicationContext</code>. The properties are stored in the <code>singleton_properties_instance_container</code>.</p> </li> <li> <p>Dependency Injection:     PySpring's dependency injection mechanism ensures that any required properties are injected into a bean before it is created. This is done by inspecting the type annotations of the bean creation function.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#how-it-works","title":"How it Works:","text":"<ol> <li> <p>Configuration:     The application is configured to load properties from a specific file as defined in <code>app-config.json</code>.</p> </li> <li> <p>Loading Properties:     During initialization, <code>PySpringApplication</code> uses the <code>_PropertiesLoader</code> to load properties into a dictionary. The keys in the dictionary match the keys defined in the <code>Properties</code> class. The <code>load_properties()</code> method of <code>ApplicationContext</code> then makes these properties available.</p> </li> <li> <p>Bean Creation with Properties:     When a bean is created via a method in <code>BeanCollection</code>, PySpring checks for any dependencies, including properties. If a property is declared as a dependency, it will be injected into the bean before the bean is created.</p> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#example","title":"Example:","text":"<p>Suppose you have a properties class and a bean collection: <pre><code>from py_spring_core import Properties, BeanCollection\n\nclass MyProperties(Properties):\n    __key__ = \"my_properties\"\n    my_config_value: str\n\nclass MyBeanCollection(BeanCollection):\n    properties: MyProperties\n    @classmethod\n    def create_my_bean(cls) -&gt; MyBean:\n        return MyBean(cls.properties.my_config_value)\n\nclass MyBean:\n    def __init__(self, config_value: str):\n        self.config_value = config_value`\n</code></pre> In this example:</p> <ul> <li><code>MyBeanCollection</code> creates a <code>MyBean</code> instance and depends on <code>MyProperties</code> to fetch a configuration value.</li> <li>When the <code>ApplicationContext</code> initializes the bean, it first loads the properties from the properties file and injects the <code>MyProperties</code> instance into the <code>createMyBean</code> method.</li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#how-beancollection-works","title":"How BeanCollection Works","text":"<ol> <li> <p>Identifying Bean Creation Functions:     The <code>scan_beans()</code> method identifies bean creation methods by checking if their names start with a specific identifier, which is <code>create</code> by default. For example, a method named <code>createMyBean</code> would be recognized as a bean creation method.</p> </li> <li> <p>Creating <code>BeanView</code> Instances:     For each method found, <code>scan_beans()</code> creates a <code>BeanView</code> instance. This object stores information about the bean, such as the creation function and the bean's class type.</p> </li> <li> <p>Bean Validation:     The <code>is_valid_bean()</code> method within <code>BeanView</code> checks whether the name of the bean matches the name of the class it is supposed to create. For instance, if a method is annotated to return an object of type <code>MyBean</code>, the bean's name must also be <code>MyBean</code>.</p> </li> <li> <p>Dependency Injection:     While <code>BeanCollection</code> is responsible for creating bean instances, dependency injection ensures that any required dependencies (including properties) are automatically injected into the beans.</p> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#integration-with-pyspring","title":"Integration with PySpring","text":"<ul> <li> <p>Registration:     <code>BeanCollection</code> classes are registered within the <code>ApplicationContext</code>. This allows PySpring to manage and inject these beans into other components of the application.</p> </li> <li> <p>Singleton Management:     Beans created by <code>BeanCollection</code> are treated as singletons by the <code>ApplicationContext</code>, meaning that only one instance of each bean is created and reused.</p> </li> <li> <p>Usage:     Beans managed by <code>BeanCollection</code> can be accessed through the <code>ApplicationContext</code> using the <code>get_bean()</code> method.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#benefits-of-using-beancollection","title":"Benefits of Using BeanCollection","text":"<ul> <li> <p>Loose Coupling:     The application code does not need to know how third-party objects are created, promoting separation of concerns and flexibility.</p> </li> <li> <p>Centralized Management:     Beans are managed in one central location, making it easier to find and maintain them.</p> </li> <li> <p>Simplified Integration:     <code>BeanCollection</code> provides a standardized approach to integrating third-party or external code without needing to modify it.</p> </li> <li> <p>Dependency Injection:     Beans can take advantage of PySpring's dependency injection, allowing them to access other registered components, controllers, or beans.</p> </li> <li> <p>Properties Support:     <code>BeanCollection</code> can load properties before bean creation, making it possible to configure beans dynamically using values from external properties files.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#beans-interacting-with-other-components","title":"Beans Interacting with Other Components","text":"<p>Beans created within a <code>BeanCollection</code> can interact with other components and properties defined within the project, not just the properties used during their initial creation. PySpring's dependency injection mechanism allows these beans to access other registered entities (components, beans, and properties) after they are instantiated.</p>"},{"location":"guide/entities-in-framework/bean-collection/#how-this-interaction-works","title":"How This Interaction Works:","text":"<ul> <li> <p>Dependency Injection:     When a bean is created, PySpring examines the type hints of the bean creation method, as well as the class definitions of other components, for type annotations. It uses these annotations to inject the necessary dependencies into the bean, including other beans, properties, and components.</p> </li> <li> <p>Component Interaction:     In your example, <code>ExampleService</code> has type hints for <code>ExampleProperties</code> and <code>MyBean</code>. When <code>ExampleService</code> is instantiated, PySpring uses dependency injection to inject the correct instances of these dependencies. Additionally, <code>AnotherExampleService</code> depends on <code>ExampleService</code>, which allows it to access properties via <code>ExampleService</code>.</p> </li> <li> <p>Lifecycle Methods:     Components like <code>ExampleService</code> and <code>AnotherExampleService</code> have lifecycle methods (<code>post_construct</code> and <code>pre_destroy</code>) that PySpring automatically calls. The <code>post_construct</code> method is executed after a component is initialized, meaning all its dependencies have been injected. At this point, the component can begin using the injected objects and properties.</p> </li> </ul> <pre><code>class MyProperties(Properties):\n    key = \"my_properties\"\n    my_config_value: str\n\n# this may be a third party class that you cannot modify\nclass MyBean: \n    def __init__(self, config_value: str):\n        self.config_value = config_value\n\n\nclass MyBeanCollection(BeanCollection):\n    properties: MyProperties\n\n    @classmethod\n    def createMyBean(cls) -&gt; MyBean:\n        return MyBean(cls.properties.my_config_value)\n\n\n\n\nclass ExampleProperties(Properties):\n    key = \"example\"\n    value: str\n\n\nclass ExampleService(Component):\n    example_properties: ExampleProperties\n    my_bean: MyBean\n\n    def post_construct(self) -&gt; None:\n        logger.info(f\"Example value: {self.example_properties.value}\")\n\n    def pre_destroy(self) -&gt; None:\n        logger.info(\"Pre destroy method called\")\n\n\nclass AnotherExampleService(Component):\n    example_service: ExampleService\n\n    def post_construct(self) -&gt; None:\n        logger.info(\"AnotherExampleService post construct called\")\n        logger.info(f\"Example value: {self.example_service.example_properties.value}\")\n</code></pre>"},{"location":"guide/entities-in-framework/bean-collection/#how-it-works-in-this-example","title":"How It Works in This Example:","text":"<ol> <li> <p>Properties Loading:     The application loads properties for <code>MyProperties</code> and <code>ExampleProperties</code> from the properties file.</p> </li> <li> <p>Bean Creation:     <code>MyBeanCollection</code> creates an instance of <code>MyBean</code>, injecting <code>MyProperties</code> during its creation.</p> </li> <li> <p>Component Instantiation:     PySpring initializes <code>ExampleService</code> and <code>AnotherExampleService</code>, injecting dependencies via type annotations.</p> </li> <li>Dependency Injection:<ul> <li><code>ExampleService</code> receives an instance of <code>ExampleProperties</code> and an instance of <code>MyBean</code>.</li> <li><code>AnotherExampleService</code> receives an instance of <code>ExampleService</code>.</li> </ul> </li> <li>Lifecycle Hook:<ul> <li>The <code>post_construct</code> method in <code>ExampleService</code> logs the value of <code>example_properties.value</code>, demonstrating that injected properties are available. It also shows that the injected <code>MyBean</code> is accessible.</li> <li>The <code>post_construct</code> method in <code>AnotherExampleService</code> logs the value of the same <code>example_properties.value</code> via <code>example_service</code>, demonstrating access to an injected component's properties.</li> </ul> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#key-takeaways","title":"Key Takeaways:","text":"<ul> <li> <p>Beans Interact with Components:     Beans created by a <code>BeanCollection</code> can interact with any component registered within the application context. This is because all these classes (beans, components, and controllers) are managed by the application context.</p> </li> <li> <p>Properties Sharing:     Properties loaded from a properties file are not only used for bean creation but can also be injected into components. This enables dynamic configuration of the application.</p> </li> <li> <p>Dependency IoC Container:     PySpring builds a dependency IoC container for all registered entities. This allows the framework to inject objects into other entities (properties, beans, components) that depend on them.</p> </li> <li> <p>Flexibility:     This approach provides a flexible architecture where components and beans can depend on each other, allowing the creation of modular and interconnected applications.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#summary","title":"Summary","text":"<p>The <code>BeanCollection</code> class provides a structured method to integrate external code into a PySpring application by treating them as managed beans. This approach enhances modularity, maintainability, and reduces tight coupling with third-party code. Additionally, it supports properties loading and dependency injection, allowing for more flexible and configurable bean creation.</p>"},{"location":"guide/entities-in-framework/component/","title":"Component","text":"<p>The <code>Component</code> class in PySpring serves as the foundational building block for creating modular, reusable functionalities. It supports lifecycle management, dependency injection, and property configuration, making it an essential entity in the PySpring framework.</p>"},{"location":"guide/entities-in-framework/component/#overview","title":"Overview","text":"<p>The <code>Component</code> class encapsulates specific functionalities and enables seamless integration with the PySpring application context. It is highly configurable, allowing developers to define scope, inject dependencies, and manage lifecycle hooks.</p>"},{"location":"guide/entities-in-framework/component/#features","title":"Features","text":"<ol> <li> <p>Reusability and Modularity    Components are designed to be reusable and modular, encapsulating specific functionalities that can be leveraged across the application.</p> </li> <li> <p>Scope Management     The scope determines whether the component instance is shared (<code>Singleton</code>) or created a new each time (<code>Prototype</code>),  which can be configured using the <code>ComponentScope</code> enum.  </p> <ul> <li><code>Singleton</code>: Single shared instance throughout the application.  </li> <li><code>Prototype</code>: A new instance is created per request.</li> </ul> </li> <li> <p>Lifecycle Hooks    Components provide hooks for initialization and destruction:  </p> <ul> <li><code>post_construct()</code>: Invoked after the component is initialized.  </li> <li><code>pre_destroy()</code>: Invoked before the component is destroyed.</li> </ul> </li> <li> <p>Dependency Injection    Components can be declare as dependencies for being injected to other components by the PySpring framework.</p> </li> <li> <p>Properties Injection    Properties from configuration files can be injected into components to simplify configuration management.</p> </li> </ol>"},{"location":"guide/entities-in-framework/component/#configuration","title":"Configuration","text":""},{"location":"guide/entities-in-framework/component/#nested-config-class","title":"Nested <code>Config</code> Class","text":"<p>The <code>Component</code> class includes a nested <code>Config</code> class to define configuration options, such as:  </p> <ul> <li>Allowed scope (<code>Singleton</code> or <code>Prototype</code>).</li> </ul>"},{"location":"guide/entities-in-framework/component/#methods","title":"Methods","text":""},{"location":"guide/entities-in-framework/component/#lifecycle-methods","title":"Lifecycle Methods","text":"<ul> <li><code>post_construct()</code>:     Called after initialization to set up the component. Subclasses can override this method.</li> <li><code>pre_destroy()</code>:     Called before destruction for cleanup. Subclasses can override this method.</li> <li><code>finish_initialization_cycle()</code>:     Invokes <code>post_construct()</code> and finalizes initialization.</li> <li><code>finish_destruction_cycle()</code>:     Invokes <code>pre_destroy()</code> and finalizes destruction.</li> </ul>"},{"location":"guide/entities-in-framework/component/#scope-management","title":"Scope Management","text":"<ul> <li><code>get_scope()</code>:   Returns the current scope of the component (<code>Singleton</code> or <code>Prototype</code>).</li> <li><code>set_scope(scope: ComponentScope)</code>:   Sets the scope of the component.</li> </ul>"},{"location":"guide/entities-in-framework/component/#usage-example","title":"Usage Example","text":"<pre><code>from py_spring_core import Component, ComponentScope\n\nclass MyComponent(Component):\n    class Config:\n        scope = ComponentScope.Singleton\n\n    def post_construct(self):\n        print(\"Component initialized.\")\n\n    def pre_destroy(self):\n        print(\"Component about to be destroyed.\")\n</code></pre>"},{"location":"guide/entities-in-framework/properties/","title":"Properties","text":"<p>The <code>Properties</code> class in PySpring provides a way to manage application-specific configurations. It allows you to load properties from a file and inject them into components.</p>"},{"location":"guide/entities-in-framework/properties/#key-features","title":"Key Features","text":"<ul> <li>Properties Registration: Properties classes are registered within the <code>ApplicationContext</code>, similar to components, controllers, and bean collections.</li> <li>Configuration Management:  <code>Properties</code> classes provide a structured way to manage application settings. They are loaded from a properties file, typically in JSON or YAML format.</li> <li>Unique Identifiers: Each <code>Properties</code> class has a unique key (<code>__key__</code>) that is used to identify it within the application. This key must be set as a class-level attribute in your <code>Properties</code> subclass.</li> <li>Automatic Loading and Injection: PySpring automatically loads properties during the application initialization process and injects them into components where they are needed.</li> <li>File Format Support: Properties can be loaded from JSON or YAML files. The <code>_PropertiesLoader</code> class handles the parsing of these files.</li> <li>Validation: The <code>Properties</code> class uses <code>Pydantic</code> for data validation. This ensures that the loaded properties conform to the expected schema.</li> <li>Singleton Scope: Properties are typically loaded as singletons within the application context and are shared across the application.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-to-define-properties","title":"How to Define Properties","text":"<p>To define your properties, you need to create a class that inherits from <code>Properties</code> and set the <code>__key__</code> class variable . This key must be a unique string that will be used to identify this <code>Properties</code> class.</p> <pre><code>from py_spring_core import Properties\nfrom pydantic import Field\n\nclass AppConfigProperties(Properties):\n    __key__ = \"app_config\" # Unique key for this properties class\n    app_name: str\n    version: str = Field(default=\"0.1.0\")\n    log_level: str = \"INFO\"\n</code></pre> <p>In the above example:</p> <ul> <li><code>AppConfigProperties</code> inherits from the base <code>Properties</code> class.</li> <li><code>__key__</code> is set to <code>\"app_config\"</code>, which is used to identify this specific set of properties.</li> <li><code>app_name</code>, <code>version</code>, and <code>log_level</code> are properties defined using Pydantic's field syntax.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-properties-are-loaded","title":"How Properties are Loaded","text":"<p>The <code>_PropertiesLoader</code> class is used to load properties from a file.</p> <ol> <li>During application startup, the <code>PySpringApplication</code> initializes an <code>ApplicationContext</code> that loads the properties.</li> <li>The application scans for all classes that inherit from <code>Properties</code>.</li> <li>The properties file path is defined in the application config (e.g., <code>./application-properties.json</code> or <code>./application-properties.yaml</code>).</li> <li>The loader attempts to read and parse the file based on its extension (<code>.json</code>, <code>.yaml</code>, or <code>.yml</code>).</li> <li>The loader validates the properties against the classes that inherit from <code>Properties</code>, ensuring the keys match what has been defined in the application, and raises an error if validation fails.</li> <li>Once loaded, the properties are stored in the <code>ApplicationContext</code> and are accessible for dependency injection.</li> </ol>"},{"location":"guide/entities-in-framework/properties/#how-to-use-properties","title":"How to Use Properties","text":""},{"location":"guide/entities-in-framework/properties/#dependency-injection","title":"Dependency Injection","text":"<p>Once properties are loaded, you can inject them into your components using type annotations.</p> <p><pre><code>from py_spring_core import Component, Properties\nfrom .app_config_properties import AppConfigProperties\n\nclass MyComponent(Component):\n    app_config: AppConfigProperties\n\n    def post_construct(self):\n        print(f\"App Name: {self.app_config.app_name}\")\n        print(f\"Log Level: {self.app_config.log_level}\")`\n</code></pre> In this example:</p> <ul> <li>The <code>MyComponent</code> class has a type annotation <code>app_config: AppConfigProperties</code>, where <code>AppConfigProperties</code> is the properties class defined above.</li> <li>The application context automatically injects an instance of <code>AppConfigProperties</code> into the <code>app_config</code> attribute of the <code>MyComponent</code> instance.</li> <li>The properties can then be accessed within the <code>MyComponent</code>'s methods.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#accessing-properties-directly","title":"Accessing Properties Directly","text":"<p>You can also access properties directly from the <code>_PropertiesLoader</code> if needed. Note, this is typically not necessary if you are using dependency injection.</p> <pre><code>from py_spring_core.core.entities.properties.properties_loader import _PropertiesLoader\n\napp_config = _PropertiesLoader.get_properties(\"app_config\")\n\nif app_config:\n    print(f\"Direct access: App Name: {app_config.app_name}\")`\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#configuration-file-examples","title":"Configuration File Examples","text":""},{"location":"guide/entities-in-framework/properties/#json","title":"JSON","text":"<p>A JSON properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass.</p> <pre><code>{\n  \"app_config\": {\n    \"app_name\": \"My Cool App\",\n    \"version\": \"1.2.3\",\n    \"log_level\": \"DEBUG\"\n  }\n}\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#yaml","title":"YAML","text":"<p>A YAML properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass. <pre><code>app_config:\n  app_name: My Cool App\n  version: 1.2.3\n  log_level: DEBUG`\n</code></pre></p>"},{"location":"guide/entities-in-framework/properties/#important-considerations","title":"Important Considerations","text":"<ul> <li>Key Uniqueness: Ensure that each <code>Properties</code> class has a unique <code>__key__</code> to avoid conflicts.</li> <li>File Path: The properties file path must be correctly configured in the application's configuration file.</li> <li>File Format: PySpring supports both JSON and YAML formats for properties files.</li> <li>Validation: Ensure that your properties files match the structure defined in your <code>Properties</code> classes. Pydantic will enforce data types and raise errors if there are mismatches.</li> <li>Dependency Injection: For loose coupling, use dependency injection to make your properties available to components, which is typically preferred over directly accessing properties from <code>_PropertiesLoader</code>.</li> <li>Error Handling: Be aware of the exceptions that can be raised during properties loading, such as <code>InvalidPropertiesKeyError</code>, and <code>TypeError</code> if the properties are not found or are not properly configured.</li> </ul> <p>By using the <code>Properties</code> class, you can effectively manage your application's configurations in a structured and maintainable way.</p>"},{"location":"guide/entities-in-framework/rest-controller/","title":"RestController","text":"<p>The <code>RestController</code> class in PySpring serves as a base class for building RESTful API controllers. It provides a structured way to define API endpoints, handle HTTP requests, and manage middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#key-features","title":"Key Features","text":"<ol> <li>Base Class: Acts as a base class that should be extended for creating specific controllers.</li> <li>Routing: Provides a mechanism to register routes using FastAPI's routing capabilities.</li> <li>Middleware Support: Allows registration of middleware for pre- and post-request processing.</li> <li>FastAPI Integration: Leverages FastAPI's features for building high-performance APIs.</li> <li>Configuration: Supports configuration of the base URL prefix for controller routes.</li> <li>Automatic Registration: Automatically integrates controllers with the application context and FastAPI during initialization.</li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#how-to-define-a-restcontroller","title":"How to Define a RestController","text":""},{"location":"guide/entities-in-framework/rest-controller/#create-a-controller-class","title":"Create a Controller Class","text":"<p>Extend the <code>RestController</code> class and use the route mapping decorators to define your API endpoints. Optionally, override <code>register_middlewares()</code> to add middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#example","title":"Example:","text":"<pre><code>from py_spring_core import RestController\nfrom py_spring_core import GetMapping, PostMapping\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\nclass MyController(RestController):\n    class Config:\n        prefix = \"/api/items\"  # Base URL prefix for this controller\n\n    @GetMapping(\"/\")\n    def read_items(self):\n        return {\"message\": \"List of items\"}\n\n    @GetMapping(\"/{item_id}\")\n    def read_item(self, item_id: int):\n        return {\"message\": f\"Details for item {item_id}\"}\n\n    @PostMapping(\"/\", status_code=201)\n    def create_item(self, item: Item):\n        return item\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#key-points","title":"Key Points:","text":"<ul> <li>Use the <code>Config</code> inner class to set the route prefix.</li> <li>Define routes using the route mapping decorators (<code>@GetMapping</code>, <code>@PostMapping</code>, etc.).</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#automatic-registration-process","title":"Automatic Registration Process","text":"<ol> <li>During application startup, PySpring scans for classes inheriting from <code>RestController</code>.</li> <li>The <code>_handle_register_rest_controller()</code> method:<ul> <li>Registers the controller with the application context.</li> <li>Initializes an <code>APIRouter</code> instance.</li> <li>Automatically registers routes defined with decorators.</li> <li>Includes the controller's router in the main FastAPI application.</li> <li>Calls <code>register_middlewares()</code> for middleware registration.</li> </ul> </li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#defining-routes","title":"Defining Routes","text":"<p>PySpring provides a declarative approach to route definition using decorators, similar to Spring's annotation-based routing. This provides a cleaner and more type-safe way to define API endpoints.</p>"},{"location":"guide/entities-in-framework/rest-controller/#available-decorators","title":"Available Decorators:","text":"<ul> <li><code>@GetMapping</code>: For HTTP GET requests</li> <li><code>@PostMapping</code>: For HTTP POST requests</li> <li><code>@PutMapping</code>: For HTTP PUT requests</li> <li><code>@DeleteMapping</code>: For HTTP DELETE requests</li> <li><code>@PatchMapping</code>: For HTTP PATCH requests</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#example-usage","title":"Example Usage:","text":"<pre><code>from py_spring_core import RestController\nfrom py_spring_core import GetMapping, PostMapping, PutMapping, DeleteMapping\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n    email: str\n\nclass UserController(RestController):\n    class Config:\n        prefix = \"/api/users\"\n\n    @GetMapping(\"/\")\n    def get_users(self):\n        return {\"users\": []}\n\n    @GetMapping(\"/{user_id}\")\n    def get_user(self, user_id: int):\n        return {\"user_id\": user_id}\n\n    @PostMapping(\"/\")\n    def create_user(self, user: User):\n        return {\"message\": \"User created\", \"user\": user}\n\n    @PutMapping(\"/{user_id}\")\n    def update_user(self, user_id: int, user: User):\n        return {\"message\": f\"User {user_id} updated\", \"user\": user}\n\n    @DeleteMapping(\"/{user_id}\")\n    def delete_user(self, user_id: int):\n        return {\"message\": f\"User {user_id} deleted\"}\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#key-benefits","title":"Key Benefits:","text":"<ol> <li>Type Safety: Decorators provide better type checking and IDE support</li> <li>Cleaner Code: Route definitions are more concise and readable</li> <li>Automatic Registration: Routes are automatically registered during application initialization</li> <li>Class-Level Prefixing: Still supports the <code>Config.prefix</code> for base URL prefixing</li> <li>Preserved Metadata: Function metadata is preserved using <code>functools.wraps</code></li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#technical-details","title":"Technical Details:","text":"<ul> <li>Routes are stored in a static <code>RouteMapping.routes</code> dictionary</li> <li>Each route is registered with its HTTP method, path, and handler function</li> <li>Route registration happens during application initialization</li> <li>Decorators preserve function metadata for better introspection</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#defining-middlewares","title":"Defining Middlewares","text":"<p>Override <code>register_middlewares()</code></p>"},{"location":"guide/event-system/","title":"Event System","text":"<p>The Event System in PySpring provides a powerful way to implement event-driven architecture in your applications. It allows components to communicate in a decoupled manner through events, following the publish-subscribe pattern.</p>"},{"location":"guide/event-system/#overview","title":"Overview","text":"<p>The Event System consists of two main components:</p> <ol> <li><code>ApplicationEventPublisher</code>: The core component for publishing events</li> <li><code>ApplicationEventHandlerRegistry</code>: Manages event handler registration and execution</li> </ol>"},{"location":"guide/event-system/#key-features","title":"Key Features","text":"<ul> <li>Thread-safe event publishing mechanism</li> <li>Decorator-based event listener registration</li> <li>Asynchronous event processing</li> <li>Type-safe events using Pydantic models</li> <li>Automatic event handler initialization</li> <li>Integration with the component system</li> </ul>"},{"location":"guide/event-system/#usage","title":"Usage","text":""},{"location":"guide/event-system/#creating-events","title":"Creating Events","text":"<p>Events are defined as Pydantic models that inherit from <code>ApplicationEvent</code>:</p> <pre><code>from py_spring_core import ApplicationEvent\n\nclass MyEvent(ApplicationEvent):\n    message: str\n</code></pre>"},{"location":"guide/event-system/#publishing-events","title":"Publishing Events","text":"<p>To publish events, inject the <code>ApplicationEventPublisher</code> into your component:</p> <pre><code>from py_spring_core import ApplicationEventPublisher, Component\n\nclass MyComponent(Component):\n    event_publisher: ApplicationEventPublisher\n\n    def do_something(self):\n        self.event_publisher.publish(MyEvent(message=\"Hello World!\"))\n</code></pre>"},{"location":"guide/event-system/#subscribing-to-events","title":"Subscribing to Events","text":"<p>Use the <code>@EventListener</code> decorator to subscribe to events. Event listeners must inherit from the <code>Component</code> class:</p> <pre><code>from py_spring_core import Component, EventListener\n\nclass MyListener(Component):\n    @EventListener(MyEvent)\n    def handle_event(self, event: MyEvent):\n        print(f\"Received event: {event.message}\")\n</code></pre> <p>The event listener will be automatically registered during application startup and will receive events of the specified type.</p>"},{"location":"guide/event-system/#technical-details","title":"Technical Details","text":""},{"location":"guide/event-system/#event-processing","title":"Event Processing","text":"<ul> <li>Events are processed asynchronously in a dedicated thread</li> <li>The system uses a thread-safe queue for event distribution</li> <li>Event handlers are automatically registered during application startup</li> <li>Events are validated using Pydantic models</li> </ul>"},{"location":"guide/event-system/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Event Design</p> <ul> <li>Keep events focused and specific</li> <li>Use meaningful event names</li> <li>Include only necessary data in events</li> </ul> </li> <li> <p>Event Handling</p> <ul> <li>Keep event handlers lightweight</li> <li>Avoid long-running operations in event handlers</li> <li>Use proper error handling in event handlers</li> </ul> </li> </ol>"},{"location":"guide/event-system/#example","title":"Example","text":"<p>Here's a complete example showing event publishing and handling:</p> <pre><code>from py_spring_core import (\n    ApplicationEvent,\n    ApplicationEventPublisher,\n    EventListener,\n    Component\n)\n\n# Define an event\nclass UserCreatedEvent(ApplicationEvent):\n    user_id: str\n    username: str\n\n# Publisher component\nclass UserService(Component):\n    event_publisher: ApplicationEventPublisher\n\n    def create_user(self, username: str):\n        user_id = \"generated_id\"  # In real app, generate proper ID\n        self.event_publisher.publish(UserCreatedEvent(\n            user_id=user_id,\n            username=username\n        ))\n        return user_id\n\n\nclass UserNotificationListener(Component):\n    @EventListener(UserCreatedEvent)\n    def send_welcome_email(self, event: UserCreatedEvent):\n        print(f\"Sending welcome email to: {event.username}\")\n\nclass UserEventListener(Component):\n    @EventListener(UserCreatedEvent)\n    def handle_user_created(self, event: UserCreatedEvent):\n        print(f\"New user created: {event.username} (ID: {event.user_id})\")\n</code></pre>"},{"location":"guide/event-system/#version-information","title":"Version Information","text":"<p>This feature is available in PySpring version 0.0.11 and later.</p>"},{"location":"guide/event-system/#dependencies","title":"Dependencies","text":"<p>The Event System is built into PySpring core and doesn't require additional dependencies. </p>"},{"location":"guide/pyspring-model/","title":"PySpringModel","text":"<p>PySpringModel is a Python module built on top of PySpring that provides a simple and efficient way to interact with SQL databases. It leverages the power of SQLAlchemy and SQLModel to provide a streamlined interface for CRUD operations, and integrates seamlessly with the PySpring framework for Dependency Injection and RESTful API development.</p>"},{"location":"guide/pyspring-model/#features","title":"Features","text":"<ul> <li>SQLModel Integration: PySpringModel uses SQLModel as its core ORM, providing a simple and Pythonic way to define your data models and interact with your database.</li> <li>Automatic CRUD Repository: PySpringModel automatically generates a CRUD repository for each of your SQLModel entities, providing common database operations such as Create, Read, Update, and Delete.</li> <li>Managed Sessions: PySpringModel provides a context manager for database sessions, automatically handling session commit and rollback to ensure data consistency.</li> <li>Dynamic Query Generation: PySpringModel can dynamically generate and execute SQL queries based on method names in your repositories.</li> <li>Custom SQL Queries: PySpringModel supports custom SQL queries using the <code>@Query</code> decorator for complex database operations.</li> <li>RESTful API Integration: PySpringModel integrates with the PySpring framework to automatically generate basic table CRUD APIs for your SQLModel entities.</li> </ul>"},{"location":"guide/pyspring-model/#limitations","title":"Limitations","text":"<p>Important: PySpringModel currently only supports read operations (queries). The following features are not yet supported:</p> <ul> <li>Model Editing: You cannot modify model instances directly through PySpringModel</li> <li>Write Operations: Create, Update, and Delete operations are not implemented</li> <li>Data Mutations: Any operations that would change the database state are not supported</li> </ul> <p>PySpringModel is designed primarily for querying and reading data from your database. For write operations, you'll need to use SQLAlchemy directly or implement custom solutions.</p>"},{"location":"guide/pyspring-model/#installation","title":"Installation","text":"<p>Note: PySpringModel is currently under active development and is not yet available on PyPI. Please install it directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/PythonSpring/pyspring-model.git\n</code></pre>"},{"location":"guide/pyspring-model/#quick-start","title":"Quick Start","text":""},{"location":"guide/pyspring-model/#1-define-your-data-models","title":"1. Define Your Data Models","text":"<p>Define your data models by subclassing <code>PySpringModel</code>:</p> <pre><code>from py_spring_model import PySpringModel\nfrom sqlmodel import Field\n\nclass User(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field()\n    email: str = Field()\n    age: int = Field()\n    status: str = Field()\n</code></pre>"},{"location":"guide/pyspring-model/#2-create-a-repository","title":"2. Create a Repository","text":"<p>Define a repository for your model by subclassing <code>CrudRepository</code>:</p> <pre><code>from py_spring_model import CrudRepository, Query\nfrom typing import Optional, List\n\nclass UserRepository(CrudRepository[int, User]):\n    # Dynamic method-based queries (auto-implemented)\n    def find_by_name(self, name: str) -&gt; Optional[User]: ...\n    def find_by_email(self, email: str) -&gt; Optional[User]: ...\n    def find_by_name_and_email(self, name: str, email: str) -&gt; Optional[User]: ...\n    def find_by_name_or_email(self, name: str, email: str) -&gt; Optional[User]: ...\n    def find_all_by_status(self, status: str) -&gt; List[User]: ...\n    def find_all_by_age_and_status(self, age: int, status: str) -&gt; List[User]: ...\n\n    # Custom SQL queries using @Query decorator\n    @Query(\"SELECT * FROM user WHERE age &gt; {min_age}\")\n    def find_users_older_than(self, min_age: int) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE email LIKE '%{domain}%'\")\n    def find_users_by_email_domain(self, domain: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE age BETWEEN {min_age} AND {max_age}\")\n    def find_users_by_age_range(self, min_age: int, max_age: int) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/#3-use-in-your-application","title":"3. Use in Your Application","text":"<p>Use your repository in your service or controller:</p> <pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_user_by_name(self, name: str) -&gt; Optional[User]:\n        return self.user_repository.find_by_name(name)\n\n    def get_active_users_older_than(self, min_age: int) -&gt; List[User]:\n        return self.user_repository.find_users_older_than(min_age)\n</code></pre>"},{"location":"guide/pyspring-model/#4-run-your-application","title":"4. Run Your Application","text":"<p>Run your application with <code>PySpringApplication</code>:</p> <pre><code>from py_spring_core import PySpringApplication\nfrom py_spring_model.py_spring_model_provider import provide_py_spring_model\n\nPySpringApplication(\n    \"./app-config.json\",\n    entity_providers=[provide_py_spring_model()]\n).run()\n</code></pre>"},{"location":"guide/pyspring-model/#whats-next","title":"What's Next?","text":"<ul> <li>Learn about Dynamic Query Generation</li> <li>Explore Custom SQL Queries</li> <li>Understand Built-in CRUD Operations</li> <li>See Complete Examples</li> <li>Dive into the SQL Statement Generation Algorithm </li> </ul>"},{"location":"guide/pyspring-model/crud-operations/","title":"Built-in Read Operations","text":"<p>Note: PySpringModel currently only supports read operations. Write operations (Create, Update, Delete) are not yet implemented.</p> <p>The <code>CrudRepository</code> provides a comprehensive set of built-in methods for common database read operations. These methods handle data retrieval with automatic session management and error handling.</p>"},{"location":"guide/pyspring-model/crud-operations/#read-operations","title":"Read Operations","text":""},{"location":"guide/pyspring-model/crud-operations/#find-by-primary-key","title":"Find by Primary Key","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    # Find a single entity by its primary key\n    def find_by_id(self, id: int) -&gt; Optional[User]: ...\n\n    # Find multiple entities by their primary keys\n    def find_all_by_ids(self, ids: List[int]) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#find-all-records","title":"Find All Records","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    # Find all entities in the table\n    def find_all(self) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#usage-examples","title":"Usage Examples","text":"<pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n        return self.user_repository.find_by_id(user_id)\n\n    def get_users_by_ids(self, user_ids: List[int]) -&gt; List[User]:\n        return self.user_repository.find_all_by_ids(user_ids)\n\n    def get_all_users(self) -&gt; List[User]:\n        return self.user_repository.find_all()\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#write-operations-not-yet-supported","title":"Write Operations (Not Yet Supported)","text":"<p>The following operations are planned but not yet implemented in PySpringModel:</p>"},{"location":"guide/pyspring-model/crud-operations/#save-single-entity","title":"Save Single Entity","text":"<pre><code># This functionality is not yet available\n# def save(self, entity: User) -&gt; User: ...\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#save-multiple-entities","title":"Save Multiple Entities","text":"<pre><code># This functionality is not yet available\n# def save_all(self, entities: List[User]) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#delete-operations","title":"Delete Operations","text":"<pre><code># This functionality is not yet available\n# def delete(self, entity: User) -&gt; None: ...\n# def delete_by_id(self, id: int) -&gt; None: ...\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#complete-read-operations-example","title":"Complete Read Operations Example","text":"<p>Here's a complete example showing all available read operations:</p> <pre><code>from py_spring_model import PySpringModel, CrudRepository\nfrom sqlmodel import Field\nfrom typing import Optional, List\n\n# Model definition\nclass User(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field()\n    email: str = Field()\n    age: int = Field()\n    status: str = Field()\n\n# Repository with read operations only\nclass UserRepository(CrudRepository[int, User]):\n    # Dynamic queries\n    def find_by_name(self, name: str) -&gt; Optional[User]: ...\n    def find_all_by_status(self, status: str) -&gt; List[User]: ...\n\n# Service using read operations only\nclass UserService:\n    user_repository: UserRepository\n\n    # Read operations\n    def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n        return self.user_repository.find_by_id(user_id)\n\n    def get_user_by_name(self, name: str) -&gt; Optional[User]:\n        return self.user_repository.find_by_name(name)\n\n    def get_all_users(self) -&gt; List[User]:\n        return self.user_repository.find_all()\n\n    def get_active_users(self) -&gt; List[User]:\n        return self.user_repository.find_all_by_status(\"active\")\n\n    def get_users_by_ids(self, user_ids: List[int]) -&gt; List[User]:\n        return self.user_repository.find_all_by_ids(user_ids)\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#session-management","title":"Session Management","text":"<p>PySpringModel automatically handles database sessions for read operations:</p>"},{"location":"guide/pyspring-model/crud-operations/#automatic-session-handling","title":"Automatic Session Handling","text":"<pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_user_data(self, user_id: int) -&gt; Optional[dict]:\n        # Session is automatically managed for read operations\n        user = self.user_repository.find_by_id(user_id)\n        if user:\n            return {\n                \"id\": user.id,\n                \"name\": user.name,\n                \"email\": user.email,\n                \"age\": user.age,\n                \"status\": user.status\n            }\n        return None\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#error-handling","title":"Error Handling","text":"<p>PySpringModel provides robust error handling for read operations:</p>"},{"location":"guide/pyspring-model/crud-operations/#common-error-scenarios","title":"Common Error Scenarios","text":"<pre><code>class UserService:\n    user_repository: UserRepository\n\n    def safe_get_user(self, user_id: int) -&gt; Optional[User]:\n        try:\n            return self.user_repository.find_by_id(user_id)\n        except Exception as e:\n            # Handle database connection errors, etc.\n            print(f\"Error retrieving user: {e}\")\n            return None\n\n    def safe_get_users_by_status(self, status: str) -&gt; List[User]:\n        try:\n            return self.user_repository.find_all_by_status(status)\n        except Exception as e:\n            # Handle database errors\n            print(f\"Error retrieving users: {e}\")\n            return []\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/pyspring-model/crud-operations/#batch-reading","title":"Batch Reading","text":"<pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_multiple_users(self, user_ids: List[int]) -&gt; List[User]:\n        # Efficient batch reading\n        return self.user_repository.find_all_by_ids(user_ids)\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#selective-loading","title":"Selective Loading","text":"<pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_user_names_only(self) -&gt; List[str]:\n        # Use custom queries for selective loading\n        users = self.user_repository.find_all()\n        return [user.name for user in users]\n</code></pre>"},{"location":"guide/pyspring-model/crud-operations/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate read methods: Choose the right read method for your use case</li> <li>Handle errors gracefully: Always handle potential exceptions in your service layer</li> <li>Use batch operations: Prefer batch operations for multiple entities</li> <li>Monitor performance: Use custom queries for complex operations that can't be handled by built-in methods</li> <li>Plan for future write operations: Design your models and repositories with future write operations in mind</li> <li>Use SQLAlchemy for writes: For now, use SQLAlchemy directly for any write operations you need </li> </ol>"},{"location":"guide/pyspring-model/custom-queries/","title":"Custom SQL Queries","text":"<p>For complex queries that can't be expressed through method names, PySpringModel supports custom SQL queries using the <code>@Query</code> decorator. This allows you to write raw SQL while still benefiting from PySpringModel's type safety and parameter handling.</p>"},{"location":"guide/pyspring-model/custom-queries/#basic-custom-queries","title":"Basic Custom Queries","text":""},{"location":"guide/pyspring-model/custom-queries/#simple-where-clauses","title":"Simple WHERE Clauses","text":"<pre><code>from py_spring_model import CrudRepository, Query\nfrom typing import List\n\nclass UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE age &gt; {min_age}\")\n    def find_users_older_than(self, min_age: int) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE age &lt; {max_age}\")\n    def find_users_younger_than(self, max_age: int) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE email LIKE '%{domain}%'\")\n    def find_users_by_email_domain(self, domain: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#single-result-queries","title":"Single Result Queries","text":"<p>For queries that should return at most one result, use <code>Optional[Model]</code> as the return type:</p> <pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE email = {email} LIMIT 1\")\n    def get_user_by_email(self, email: str) -&gt; Optional[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE name = {name} AND status = {status} LIMIT 1\")\n    def get_user_by_name_and_status(self, name: str, status: str) -&gt; Optional[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#complex-custom-queries","title":"Complex Custom Queries","text":""},{"location":"guide/pyspring-model/custom-queries/#multiple-conditions","title":"Multiple Conditions","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE age BETWEEN {min_age} AND {max_age} AND status = {status}\")\n    def find_users_by_age_range_and_status(self, min_age: int, max_age: int, status: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE name LIKE %{name_pattern}% OR email LIKE %{email_pattern}%\")\n    def search_users_by_name_or_email(self, name_pattern: str, email_pattern: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#ordering-and-limiting","title":"Ordering and Limiting","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user ORDER BY age DESC LIMIT {limit}\")\n    def find_oldest_users(self, limit: int) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE status = {status} ORDER BY name ASC LIMIT {limit}\")\n    def find_users_by_status_ordered(self, status: str, limit: int) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#aggregation-queries","title":"Aggregation Queries","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT COUNT(*) as count FROM user WHERE status = {status}\")\n    def count_users_by_status(self, status: str) -&gt; int: ...\n\n    @Query(\"SELECT AVG(age) as average_age FROM user WHERE status = {status}\")\n    def get_average_age_by_status(self, status: str) -&gt; float: ...\n\n    @Query(\"SELECT status, COUNT(*) as count FROM user GROUP BY status\")\n    def get_user_count_by_status(self) -&gt; List[dict]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#parameter-substitution","title":"Parameter Substitution","text":"<p>The <code>@Query</code> decorator supports parameter substitution using <code>{parameter_name}</code> syntax:</p>"},{"location":"guide/pyspring-model/custom-queries/#basic-parameter-substitution","title":"Basic Parameter Substitution","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE name = {name}\")\n    def find_by_name(self, name: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE age &gt; {min_age} AND age &lt; {max_age}\")\n    def find_by_age_range(self, min_age: int, max_age: int) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#string-pattern-matching","title":"String Pattern Matching","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE name LIKE %{name_pattern}%\")\n    def search_by_name_pattern(self, name_pattern: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE email LIKE '{domain}%'\")\n    def find_users_by_email_prefix(self, domain: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#multiple-parameter-types","title":"Multiple Parameter Types","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE age &gt;= {min_age} AND age &lt;= {max_age} AND status IN ({statuses})\")\n    def find_users_by_criteria(self, min_age: int, max_age: int, statuses: List[str]) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#advanced-query-features","title":"Advanced Query Features","text":""},{"location":"guide/pyspring-model/custom-queries/#joins","title":"Joins","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"\"\"\n        SELECT u.* FROM user u \n        JOIN user_profile p ON u.id = p.user_id \n        WHERE p.city = {city}\n    \"\"\")\n    def find_users_by_city(self, city: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#subqueries","title":"Subqueries","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"\"\"\n        SELECT * FROM user \n        WHERE age &gt; (SELECT AVG(age) FROM user WHERE status = {status})\n    \"\"\")\n    def find_users_older_than_average(self, status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#complex-where-clauses","title":"Complex WHERE Clauses","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"\"\"\n        SELECT * FROM user \n        WHERE (age BETWEEN {min_age} AND {max_age}) \n        AND (status = {status} OR status = {alt_status})\n        AND name IS NOT NULL\n    \"\"\")\n    def find_users_complex_criteria(self, min_age: int, max_age: int, status: str, alt_status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#query-decorator-features","title":"Query Decorator Features","text":"<p>The <code>@Query</code> decorator provides several features:</p>"},{"location":"guide/pyspring-model/custom-queries/#type-safety","title":"Type Safety","text":"<ul> <li>Method parameters must match SQL parameters</li> <li>Return type inference for <code>Optional[Model]</code> and <code>List[Model]</code></li> <li>Parameter validation at runtime</li> </ul>"},{"location":"guide/pyspring-model/custom-queries/#error-handling","title":"Error Handling","text":"<ul> <li>Validates required parameters are provided</li> <li>Checks parameter types match expected types</li> <li>Provides clear error messages for missing or invalid parameters</li> </ul>"},{"location":"guide/pyspring-model/custom-queries/#sql-injection-protection","title":"SQL Injection Protection","text":"<ul> <li>Parameters are properly escaped and bound</li> <li>Prevents SQL injection attacks</li> <li>Safe handling of user input</li> </ul>"},{"location":"guide/pyspring-model/custom-queries/#best-practices","title":"Best Practices","text":""},{"location":"guide/pyspring-model/custom-queries/#1-use-descriptive-method-names","title":"1. Use Descriptive Method Names","text":"<pre><code># Good\n@Query(\"SELECT * FROM user WHERE age &gt; {min_age}\")\ndef find_users_older_than(self, min_age: int) -&gt; List[User]: ...\n\n# Avoid\n@Query(\"SELECT * FROM user WHERE age &gt; {age}\")\ndef query1(self, age: int) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#2-keep-queries-readable","title":"2. Keep Queries Readable","text":"<pre><code># Good - Multi-line for complex queries\n@Query(\"\"\"\n    SELECT u.* FROM user u \n    JOIN user_profile p ON u.id = p.user_id \n    WHERE p.city = {city} AND u.status = {status}\n\"\"\")\ndef find_users_by_city_and_status(self, city: str, status: str) -&gt; List[User]: ...\n\n# Avoid - Single line for complex queries\n@Query(\"SELECT u.* FROM user u JOIN user_profile p ON u.id = p.user_id WHERE p.city = {city} AND u.status = {status}\")\ndef find_users_by_city_and_status(self, city: str, status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#3-use-appropriate-return-types","title":"3. Use Appropriate Return Types","text":"<pre><code># Single result\n@Query(\"SELECT * FROM user WHERE email = {email} LIMIT 1\")\ndef get_user_by_email(self, email: str) -&gt; Optional[User]: ...\n\n# Multiple results\n@Query(\"SELECT * FROM user WHERE status = {status}\")\ndef find_users_by_status(self, status: str) -&gt; List[User]: ...\n\n# Aggregation result\n@Query(\"SELECT COUNT(*) as count FROM user WHERE status = {status}\")\ndef count_users_by_status(self, status: str) -&gt; int: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#4-handle-edge-cases","title":"4. Handle Edge Cases","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @Query(\"SELECT * FROM user WHERE name LIKE %{name_pattern}% OR name IS NULL\")\n    def search_users_by_name_pattern(self, name_pattern: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE age &gt;= {min_age} OR age IS NULL\")\n    def find_users_by_min_age(self, min_age: int) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/custom-queries/#limitations","title":"Limitations","text":"<ul> <li>Complex database-specific features may require raw SQLAlchemy usage</li> <li>Some advanced SQL features might not be supported</li> <li>Performance optimization for very complex queries may require manual tuning</li> <li>Database-specific SQL dialects may not be fully supported </li> </ul>"},{"location":"guide/pyspring-model/dynamic-queries/","title":"Dynamic Query Generation","text":"<p>PySpringModel automatically implements query methods based on their names. The method names follow a specific pattern that allows you to define queries without writing any SQL code.</p>"},{"location":"guide/pyspring-model/dynamic-queries/#method-naming-conventions","title":"Method Naming Conventions","text":"<p>The dynamic query generation follows these naming conventions:</p> <ul> <li>Prefixes: <code>find_by_</code>, <code>get_by_</code>, <code>find_all_by_</code>, <code>get_all_by_</code></li> <li>Single field: <code>find_by_name</code> \u2192 <code>WHERE name = ?</code></li> <li>Multiple fields with AND: <code>find_by_name_and_email</code> \u2192 <code>WHERE name = ? AND email = ?</code></li> <li>Multiple fields with OR: <code>find_by_name_or_email</code> \u2192 <code>WHERE name = ? OR email = ?</code></li> <li>Return types:</li> <li><code>find_by_*</code> and <code>get_by_*</code> return <code>Optional[Model]</code></li> <li><code>find_all_by_*</code> and <code>get_all_by_*</code> return <code>List[Model]</code></li> </ul>"},{"location":"guide/pyspring-model/dynamic-queries/#single-result-queries","title":"Single Result Queries","text":"<p>These methods return <code>Optional[Model]</code> and are used when you expect at most one result:</p>"},{"location":"guide/pyspring-model/dynamic-queries/#find-by-single-field","title":"Find by Single Field","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_by_name(self, name: str) -&gt; Optional[User]: ...\n    def get_by_email(self, email: str) -&gt; Optional[User]: ...\n    def find_by_age(self, age: int) -&gt; Optional[User]: ...\n    def get_by_status(self, status: str) -&gt; Optional[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#find-by-multiple-fields-with-and-condition","title":"Find by Multiple Fields with AND Condition","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_by_name_and_email(self, name: str, email: str) -&gt; Optional[User]: ...\n    def get_by_age_and_status(self, age: int, status: str) -&gt; Optional[User]: ...\n    def find_by_name_and_age_and_status(self, name: str, age: int, status: str) -&gt; Optional[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#find-by-multiple-fields-with-or-condition","title":"Find by Multiple Fields with OR Condition","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_by_name_or_email(self, name: str, email: str) -&gt; Optional[User]: ...\n    def get_by_status_or_age(self, status: str, age: int) -&gt; Optional[User]: ...\n    def find_by_name_or_email_or_status(self, name: str, email: str, status: str) -&gt; Optional[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#multiple-result-queries","title":"Multiple Result Queries","text":"<p>These methods return <code>List[Model]</code> and are used when you expect multiple results:</p>"},{"location":"guide/pyspring-model/dynamic-queries/#find-all-by-single-field","title":"Find All by Single Field","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_all_by_status(self, status: str) -&gt; List[User]: ...\n    def get_all_by_age(self, age: int) -&gt; List[User]: ...\n    def find_all_by_name(self, name: str) -&gt; List[User]: ...\n    def get_all_by_email(self, email: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#find-all-by-multiple-fields-with-and-condition","title":"Find All by Multiple Fields with AND Condition","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_all_by_age_and_status(self, age: int, status: str) -&gt; List[User]: ...\n    def get_all_by_name_and_email(self, name: str, email: str) -&gt; List[User]: ...\n    def find_all_by_name_and_age_and_status(self, name: str, age: int, status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#find-all-by-multiple-fields-with-or-condition","title":"Find All by Multiple Fields with OR Condition","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    def find_all_by_status_or_age(self, status: str, age: int) -&gt; List[User]: ...\n    def get_all_by_name_or_email(self, name: str, email: str) -&gt; List[User]: ...\n    def find_all_by_name_or_email_or_status(self, name: str, email: str, status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#usage-examples","title":"Usage Examples","text":"<p>Here's how to use these dynamic queries in your service layer:</p> <pre><code>class UserService:\n    user_repository: UserRepository\n\n    def get_user_by_name(self, name: str) -&gt; Optional[User]:\n        return self.user_repository.find_by_name(name)\n\n    def get_user_by_email_and_status(self, email: str, status: str) -&gt; Optional[User]:\n        return self.user_repository.find_by_email_and_status(email, status)\n\n    def get_active_users(self) -&gt; List[User]:\n        return self.user_repository.find_all_by_status(\"active\")\n\n    def get_users_by_age_and_status(self, age: int, status: str) -&gt; List[User]:\n        return self.user_repository.find_all_by_age_and_status(age, status)\n\n    def search_users_by_name_or_email(self, name: str, email: str) -&gt; List[User]:\n        return self.user_repository.find_all_by_name_or_email(name, email)\n</code></pre>"},{"location":"guide/pyspring-model/dynamic-queries/#field-name-mapping","title":"Field Name Mapping","text":"<p>PySpringModel automatically maps method parameter names to database column names:</p> <ul> <li>Method parameter names are converted to lowercase for database column matching</li> <li>Underscores in parameter names are preserved</li> <li>The framework handles the mapping between Python naming conventions and SQL naming conventions</li> </ul>"},{"location":"guide/pyspring-model/dynamic-queries/#generated-sql-examples","title":"Generated SQL Examples","text":"<p>Here are examples of the SQL queries that PySpringModel generates for different method names:</p> Method Name Generated SQL <code>find_by_name(name)</code> <code>SELECT * FROM user WHERE name = ?</code> <code>find_by_email_and_status(email, status)</code> <code>SELECT * FROM user WHERE email = ? AND status = ?</code> <code>find_by_name_or_email(name, email)</code> <code>SELECT * FROM user WHERE name = ? OR email = ?</code> <code>find_all_by_status(status)</code> <code>SELECT * FROM user WHERE status = ?</code> <code>find_all_by_age_and_status(age, status)</code> <code>SELECT * FROM user WHERE age = ? AND status = ?</code> <code>find_all_by_name_or_email_or_status(name, email, status)</code> <code>SELECT * FROM user WHERE name = ? OR email = ? OR status = ?</code>"},{"location":"guide/pyspring-model/dynamic-queries/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive method names: Make your method names clear and descriptive</li> <li>Follow naming conventions: Stick to the established prefixes and patterns</li> <li>Consider return types: Use <code>find_by_</code> for single results and <code>find_all_by_</code> for multiple results</li> <li>Use AND for related conditions: Use <code>_and_</code> when conditions should all be true</li> <li>Use OR for alternatives: Use <code>_or_</code> when any condition can be true</li> <li>Keep it simple: For complex queries, consider using custom SQL with the <code>@Query</code> decorator</li> </ol>"},{"location":"guide/pyspring-model/dynamic-queries/#limitations","title":"Limitations","text":"<ul> <li>Method names must follow the exact naming pattern</li> <li>Field names in method parameters must match database column names</li> <li>Complex queries with joins, aggregations, or subqueries should use custom SQL</li> <li>The framework doesn't support dynamic field selection or complex WHERE clauses beyond AND/OR combinations </li> </ul>"},{"location":"guide/pyspring-model/examples/","title":"Complete Examples","text":"<p>Note: PySpringModel currently only supports read operations. All examples in this page focus on querying and reading data from the database.</p> <p>This page provides comprehensive examples showing how to use PySpringModel for data retrieval in real-world scenarios.</p>"},{"location":"guide/pyspring-model/examples/#basic-user-management-system","title":"Basic User Management System","text":""},{"location":"guide/pyspring-model/examples/#model-definition","title":"Model Definition","text":"<pre><code>from py_spring_model import PySpringModel\nfrom sqlmodel import Field\nfrom typing import Optional\nfrom datetime import datetime\n\nclass User(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field()\n    email: str = Field(unique=True)\n    age: int = Field()\n    status: str = Field(default=\"active\")\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\nclass UserProfile(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    bio: str = Field(default=\"\")\n    avatar_url: str = Field(default=\"\")\n    preferences: dict = Field(default_factory=dict)\n</code></pre>"},{"location":"guide/pyspring-model/examples/#repository-definition","title":"Repository Definition","text":"<pre><code>from py_spring_model import CrudRepository, Query\nfrom typing import Optional, List\n\nclass UserRepository(CrudRepository[int, User]):\n    # Dynamic queries\n    def find_by_email(self, email: str) -&gt; Optional[User]: ...\n    def find_by_name_and_status(self, name: str, status: str) -&gt; Optional[User]: ...\n    def find_all_by_status(self, status: str) -&gt; List[User]: ...\n    def find_all_by_age_and_status(self, age: int, status: str) -&gt; List[User]: ...\n\n    # Custom queries\n    @Query(\"SELECT * FROM user WHERE age &gt; {min_age} ORDER BY age DESC\")\n    def find_users_older_than(self, min_age: int) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE email LIKE '%{domain}%'\")\n    def find_users_by_email_domain(self, domain: str) -&gt; List[User]: ...\n\n    @Query(\"SELECT * FROM user WHERE created_at &gt;= {start_date}\")\n    def find_users_created_after(self, start_date: datetime) -&gt; List[User]: ...\n\n    @Query(\"SELECT COUNT(*) as count FROM user WHERE status = {status}\")\n    def count_users_by_status(self, status: str) -&gt; int: ...\n\nclass UserProfileRepository(CrudRepository[int, UserProfile]):\n    def find_by_user_id(self, user_id: int) -&gt; Optional[UserProfile]: ...\n    def find_all_by_user_ids(self, user_ids: List[int]) -&gt; List[UserProfile]: ...\n</code></pre>"},{"location":"guide/pyspring-model/examples/#service-layer-read-operations-only","title":"Service Layer (Read Operations Only)","text":"<pre><code>from typing import Optional, List, Dict\nfrom datetime import datetime, timedelta\n\nclass UserService:\n    user_repository: UserRepository\n    profile_repository: UserProfileRepository\n\n    # Read operations only\n    def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n        return self.user_repository.find_by_id(user_id)\n\n    def get_user_by_email(self, email: str) -&gt; Optional[User]:\n        return self.user_repository.find_by_email(email)\n\n    def get_user_with_profile(self, user_id: int) -&gt; Optional[Dict]:\n        user = self.user_repository.find_by_id(user_id)\n        if not user:\n            return None\n\n        profile = self.profile_repository.find_by_user_id(user_id)\n        return {\n            \"user\": user,\n            \"profile\": profile\n        }\n\n    def get_active_users(self) -&gt; List[User]:\n        return self.user_repository.find_all_by_status(\"active\")\n\n    def get_users_by_age_range(self, min_age: int, max_age: int) -&gt; List[User]:\n        return self.user_repository.find_users_older_than(min_age)\n\n    def get_recent_users(self, days: int = 7) -&gt; List[User]:\n        start_date = datetime.now() - timedelta(days=days)\n        return self.user_repository.find_users_created_after(start_date)\n\n    def get_user_statistics(self) -&gt; Dict:\n        active_count = self.user_repository.count_users_by_status(\"active\")\n        inactive_count = self.user_repository.count_users_by_status(\"inactive\")\n\n        return {\n            \"active_users\": active_count,\n            \"inactive_users\": inactive_count,\n            \"total_users\": active_count + inactive_count\n        }\n\n    def search_users(self, query: str) -&gt; List[User]:\n        # Search by name or email\n        users = self.user_repository.find_all_by_name_or_email(query, query)\n        return users\n\n    def get_users_by_domain(self, domain: str) -&gt; List[User]:\n        return self.user_repository.find_users_by_email_domain(domain)\n</code></pre>"},{"location":"guide/pyspring-model/examples/#rest-controller-read-operations-only","title":"REST Controller (Read Operations Only)","text":"<pre><code>from py_spring_core import RestController, Get, PathVariable\nfrom typing import List, Optional\n\n@RestController(\"/api/users\")\nclass UserController:\n    user_service: UserService\n\n    @Get(\"/\")\n    def get_all_users(self) -&gt; List[User]:\n        return self.user_service.get_active_users()\n\n    @Get(\"/{user_id}\")\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.user_service.get_user_by_id(user_id)\n\n    @Get(\"/{user_id}/profile\")\n    def get_user_with_profile(self, user_id: int) -&gt; Optional[dict]:\n        return self.user_service.get_user_with_profile(user_id)\n\n    @Get(\"/search\")\n    def search_users(self, query: str) -&gt; List[User]:\n        return self.user_service.search_users(query)\n\n    @Get(\"/statistics\")\n    def get_statistics(self) -&gt; dict:\n        return self.user_service.get_user_statistics()\n</code></pre>"},{"location":"guide/pyspring-model/examples/#e-commerce-system-example","title":"E-commerce System Example","text":""},{"location":"guide/pyspring-model/examples/#models","title":"Models","text":"<pre><code>from py_spring_model import PySpringModel\nfrom sqlmodel import Field\nfrom typing import Optional, List\nfrom datetime import datetime\nfrom decimal import Decimal\n\nclass Product(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field()\n    description: str = Field()\n    price: Decimal = Field()\n    category: str = Field()\n    stock_quantity: int = Field()\n    is_active: bool = Field(default=True)\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass Order(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    total_amount: Decimal = Field()\n    status: str = Field(default=\"pending\")\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\nclass OrderItem(PySpringModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    order_id: int = Field(foreign_key=\"order.id\")\n    product_id: int = Field(foreign_key=\"product.id\")\n    quantity: int = Field()\n    unit_price: Decimal = Field()\n    total_price: Decimal = Field()\n</code></pre>"},{"location":"guide/pyspring-model/examples/#repositories","title":"Repositories","text":"<pre><code>from py_spring_model import CrudRepository, Query\nfrom typing import Optional, List\n\nclass ProductRepository(CrudRepository[int, Product]):\n    def find_by_category(self, category: str) -&gt; List[Product]: ...\n    def find_by_name_and_category(self, name: str, category: str) -&gt; Optional[Product]: ...\n    def find_all_by_is_active(self, is_active: bool) -&gt; List[Product]: ...\n\n    @Query(\"SELECT * FROM product WHERE price BETWEEN {min_price} AND {max_price}\")\n    def find_by_price_range(self, min_price: Decimal, max_price: Decimal) -&gt; List[Product]: ...\n\n    @Query(\"SELECT * FROM product WHERE stock_quantity &gt; 0 AND is_active = true\")\n    def find_available_products(self) -&gt; List[Product]: ...\n\n    @Query(\"SELECT category, COUNT(*) as count FROM product GROUP BY category\")\n    def get_product_count_by_category(self) -&gt; List[dict]: ...\n\nclass OrderRepository(CrudRepository[int, Order]):\n    def find_by_user_id(self, user_id: int) -&gt; List[Order]: ...\n    def find_by_status(self, status: str) -&gt; List[Order]: ...\n    def find_by_user_id_and_status(self, user_id: int, status: str) -&gt; List[Order]: ...\n\n    @Query(\"SELECT * FROM `order` WHERE created_at &gt;= {start_date} AND created_at &lt;= {end_date}\")\n    def find_orders_by_date_range(self, start_date: datetime, end_date: datetime) -&gt; List[Order]: ...\n\n    @Query(\"SELECT SUM(total_amount) as total FROM `order` WHERE status = {status}\")\n    def get_total_amount_by_status(self, status: str) -&gt; Decimal: ...\n\nclass OrderItemRepository(CrudRepository[int, OrderItem]):\n    def find_by_order_id(self, order_id: int) -&gt; List[OrderItem]: ...\n    def find_by_product_id(self, product_id: int) -&gt; List[OrderItem]: ...\n</code></pre>"},{"location":"guide/pyspring-model/examples/#service-layer-read-operations-only_1","title":"Service Layer (Read Operations Only)","text":"<pre><code>from decimal import Decimal\nfrom typing import List, Optional, Dict\n\nclass ProductService:\n    product_repository: ProductRepository\n\n    def get_available_products(self) -&gt; List[Product]:\n        return self.product_repository.find_available_products()\n\n    def get_products_by_category(self, category: str) -&gt; List[Product]:\n        return self.product_repository.find_by_category(category)\n\n    def get_products_by_price_range(self, min_price: Decimal, max_price: Decimal) -&gt; List[Product]:\n        return self.product_repository.find_by_price_range(min_price, max_price)\n\n    def get_product_statistics(self) -&gt; Dict:\n        return self.product_repository.get_product_count_by_category()\n\nclass OrderService:\n    order_repository: OrderRepository\n    order_item_repository: OrderItemRepository\n    product_repository: ProductRepository\n\n    def get_user_orders(self, user_id: int) -&gt; List[Order]:\n        return self.order_repository.find_by_user_id(user_id)\n\n    def get_order_with_items(self, order_id: int) -&gt; Optional[Dict]:\n        order = self.order_repository.find_by_id(order_id)\n        if not order:\n            return None\n\n        items = self.order_item_repository.find_by_order_id(order_id)\n        return {\n            \"order\": order,\n            \"items\": items\n        }\n\n    def get_orders_by_date_range(self, start_date: datetime, end_date: datetime) -&gt; List[Order]:\n        return self.order_repository.find_orders_by_date_range(start_date, end_date)\n\n    def get_order_statistics(self) -&gt; Dict:\n        pending_total = self.order_repository.get_total_amount_by_status(\"pending\")\n        completed_total = self.order_repository.get_total_amount_by_status(\"completed\")\n        cancelled_total = self.order_repository.get_total_amount_by_status(\"cancelled\")\n\n        return {\n            \"pending_total\": pending_total or Decimal('0'),\n            \"completed_total\": completed_total or Decimal('0'),\n            \"cancelled_total\": cancelled_total or Decimal('0')\n        }\n</code></pre>"},{"location":"guide/pyspring-model/examples/#application-configuration","title":"Application Configuration","text":""},{"location":"guide/pyspring-model/examples/#app-configjson","title":"app-config.json","text":"<pre><code>{\n  \"database\": {\n    \"url\": \"sqlite:///./app.db\",\n    \"echo\": false\n  },\n  \"server\": {\n    \"host\": \"localhost\",\n    \"port\": 8000\n  }\n}\n</code></pre>"},{"location":"guide/pyspring-model/examples/#main-application","title":"Main Application","text":"<pre><code>from py_spring_core import PySpringApplication\nfrom py_spring_model.py_spring_model_provider import provide_py_spring_model\n\ndef main():\n    app = PySpringApplication(\n        \"./app-config.json\",\n        entity_providers=[provide_py_spring_model()]\n    )\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/pyspring-model/examples/#important-notes","title":"Important Notes","text":"<ul> <li>Read-Only Operations: All examples focus on data retrieval and querying</li> <li>No Data Modification: PySpringModel does not support creating, updating, or deleting data</li> <li>SQLAlchemy for Writes: For write operations, use SQLAlchemy directly</li> <li>Future Enhancements: Write operations are planned for future releases</li> <li>Data Integrity: Since only read operations are supported, data integrity is maintained </li> </ul>"},{"location":"guide/pyspring-model/skip-auto-implementation/","title":"SkipAutoImplementation Decorator","text":"<p>The <code>@SkipAutoImplmentation</code> decorator allows you to exclude specific methods from automatic implementation by the <code>CrudRepositoryImplementationService</code>. This is useful when you want to provide your own custom implementation for methods that would otherwise be automatically generated based on their naming convention.</p>"},{"location":"guide/pyspring-model/skip-auto-implementation/#usage","title":"Usage","text":"<pre><code>from py_spring_model import CrudRepository, SkipAutoImplmentation\nfrom typing import Optional, List\n\nclass UserRepository(CrudRepository[int, User]):\n    # This method will be automatically implemented\n    def find_by_name(self, name: str) -&gt; Optional[User]: ...\n\n    # This method will be skipped and you must implement it yourself\n    @SkipAutoImplmentation\n    def find_by_email(self, email: str) -&gt; Optional[User]:\n        # Your custom implementation here\n        with PySpringModel.create_session() as session:\n            return session.exec(\n                select(User).where(User.email == email)\n            ).first()\n\n    # This method will also be automatically implemented\n    def find_all_by_status(self, status: str) -&gt; List[User]: ...\n</code></pre>"},{"location":"guide/pyspring-model/skip-auto-implementation/#when-to-use","title":"When to Use","text":"<p>Use the <code>@SkipAutoImplmentation</code> decorator when you need:</p> <ul> <li>Custom business logic: When the standard query logic doesn't meet your requirements</li> <li>Complex queries: When you need joins, subqueries, or other complex SQL operations</li> <li>Performance optimization: When you need to optimize specific queries</li> <li>Custom validation: When you need to add custom validation logic before or after the query</li> <li>Integration with external services: When the method needs to call external APIs or services</li> </ul>"},{"location":"guide/pyspring-model/skip-auto-implementation/#example-with-custom-logic","title":"Example with Custom Logic","text":"<pre><code>class UserRepository(CrudRepository[int, User]):\n    @SkipAutoImplmentation\n    def find_by_email(self, email: str) -&gt; Optional[User]:\n        # Add custom validation\n        if not email or '@' not in email:\n            raise ValueError(\"Invalid email format\")\n\n        # Custom implementation with additional logic\n        with PySpringModel.create_session() as session:\n            user = session.exec(\n                select(User).where(User.email == email.lower())\n            ).first()\n\n            # Add custom post-processing\n            if user and user.status == \"inactive\":\n                logger.warning(f\"Found inactive user with email: {email}\")\n\n            return user\n\n    @SkipAutoImplmentation\n    def find_all_by_status(self, status: str) -&gt; List[User]:\n        # Custom implementation with joins\n        with PySpringModel.create_session() as session:\n            return session.exec(\n                select(User)\n                .join(UserProfile)  # Assuming there's a UserProfile table\n                .where(User.status == status)\n                .order_by(User.created_at.desc())\n            ).fetchall()\n</code></pre>"},{"location":"guide/pyspring-model/skip-auto-implementation/#important-notes","title":"Important Notes","text":"<ul> <li>The decorator must be applied to methods that follow the naming convention (<code>find_by_*</code>, <code>get_by_*</code>, etc.)</li> <li>You must provide your own implementation for decorated methods</li> <li>The decorator preserves the original method signature and type annotations</li> <li>Decorated methods are completely excluded from the automatic implementation process </li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/","title":"SQL Statement Generation Algorithm","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#overview","title":"Overview","text":"<p>In PySpringModel, repository methods can be defined using expressive method names like <code>find_by_email_and_age_or_status</code>. These method names are parsed and dynamically translated into SQL queries. This allows developers to define powerful queries declaratively without writing raw SQL or using query builders explicitly.</p> <p>When you define a repository method like <code>find_by_email_and_age_or_status</code>, PySpringModel needs to convert this method name into a valid SQL query. The algorithm parses the method name, extracts field names and boolean operators, then constructs the appropriate WHERE clause.</p>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#how-it-works","title":"How It Works","text":"<p>The query generation engine transforms method names into SQL WHERE clauses using a structured, stack-based algorithm that interprets field names and boolean logic (AND/OR). It ensures correct operator precedence and type-safe condition generation via SQLAlchemy.</p>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#algorithm-steps","title":"Algorithm Steps","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#1-initial-condition-stack-creation","title":"1. Initial Condition Stack Creation","text":"<p>The algorithm starts by creating a stack of basic equality conditions:</p> <pre><code># For method: find_by_email_and_age_or_status\n# Required fields: [\"email\", \"age\", \"status\"]\n# Parameters: {\"email\": \"john@example.com\", \"age\": 25, \"status\": \"active\"}\n\n# Initial stack contains basic equality conditions\nstack = [\n    User.email == \"john@example.com\",\n    User.age == 25,\n    User.status == \"active\"\n]\n</code></pre> <p>Each condition compares a model field with its corresponding parameter value.</p>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#2-boolean-expression-processing","title":"2. Boolean Expression Processing","text":"<p>The algorithm processes boolean operators in order (left-to-right) using a stack-based approach:</p> <pre><code># Notations: [ConditionNotation.AND, ConditionNotation.OR]\n\n# Step 1: Process AND operator\n# Pop two conditions from stack\nright_condition = stack.pop()  # User.age == 25\nleft_condition = stack.pop()   # User.email == \"john@example.com\"\n\n# Combine with AND\ncombined_condition = and_(left_condition, right_condition)\n# Result: and_(User.email == \"john@example.com\", User.age == 25)\n\n# Push result back to stack\nstack = [combined_condition, User.status == \"active\"]\n\n# Step 2: Process OR operator\n# Pop two conditions from stack\nright_condition = stack.pop()  # User.status == \"active\"\nleft_condition = stack.pop()   # and_(User.email == \"john@example.com\", User.age == 25)\n\n# Combine with OR\nfinal_condition = or_(left_condition, right_condition)\n# Result: or_(and_(User.email == \"john@example.com\", User.age == 25), User.status == \"active\")\n\n# Final stack contains the complete WHERE condition\nstack = [final_condition]\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#3-final-query-construction","title":"3. Final Query Construction","text":"<p>The algorithm creates the complete SQL query by applying the final condition:</p> <pre><code># Create base SELECT statement\nbase_query = select(User)\n\n# Apply the final combined condition as WHERE clause\nfinal_query = base_query.where(stack[0])\n\n# Result: SELECT * FROM user WHERE (email = ? AND age = ?) OR status = ?\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#example-walkthrough","title":"Example Walkthrough","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#input","title":"Input","text":"<ul> <li>Method Name: <code>find_by_email_and_age_or_status</code></li> <li>Required Fields: <code>[\"email\", \"age\", \"status\"]</code></li> <li>Parameters: <code>{\"email\": \"john@example.com\", \"age\": 25, \"status\": \"active\"}</code></li> <li>Boolean Operators: <code>[AND, OR]</code></li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#step-by-step-execution","title":"Step-by-Step Execution","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#initial-state","title":"Initial State","text":"<pre><code>Stack: [email == \"john@example.com\", age == 25, status == \"active\"]\nOperators: [AND, OR]\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#step-1-process-and","title":"Step 1: Process AND","text":"<pre><code>Pop: age == 25 (right)\nPop: email == \"john@example.com\" (left)\nCombine: and_(email == \"john@example.com\", age == 25)\nStack: [and_(email == \"john@example.com\", age == 25), status == \"active\"]\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#step-2-process-or","title":"Step 2: Process OR","text":"<pre><code>Pop: status == \"active\" (right)\nPop: and_(email == \"john@example.com\", age == 25) (left)\nCombine: or_(and_(email == \"john@example.com\", age == 25), status == \"active\")\nStack: [or_(and_(email == \"john@example.com\", age == 25), status == \"active\")]\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#final-result","title":"Final Result","text":"<pre><code>SELECT * FROM user WHERE (email = ? AND age = ?) OR status = ?\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#key-characteristics","title":"Key Characteristics","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#stack-based-processing","title":"Stack-Based Processing","text":"<ul> <li>Uses a stack data structure to maintain intermediate results</li> <li>Each boolean operation pops two conditions and pushes one combined result</li> <li>Ensures proper operator precedence and grouping</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#left-to-right-evaluation","title":"Left-to-Right Evaluation","text":"<ul> <li>Processes boolean operators in the order they appear in the method name</li> <li>Maintains the logical flow of the original method name</li> <li>Supports complex nested expressions</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#dynamic-field-mapping","title":"Dynamic Field Mapping","text":"<ul> <li>Maps method parameters to model attributes automatically</li> <li>Handles different data types (strings, integers, booleans, etc.)</li> <li>Supports field name conversion between Python and SQL conventions</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#type-safety","title":"Type Safety","text":"<ul> <li>Uses SQLAlchemy's <code>ColumnElement[bool]</code> for type-safe conditions</li> <li>Prevents SQL injection through parameterized queries</li> <li>Maintains type checking throughout the process</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#extensibility","title":"Extensibility","text":"<ul> <li>Supports any number of fields and boolean operators</li> <li>Can be extended for additional operators (NOT, XOR, etc.)</li> <li>Framework for adding custom query patterns</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#memory-efficiency","title":"Memory Efficiency","text":"<ul> <li>Stack operations are O(1) for push/pop operations</li> <li>No unnecessary intermediate objects created</li> <li>Minimal memory footprint for complex expressions</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#query-optimization","title":"Query Optimization","text":"<ul> <li>Generates optimized SQLAlchemy expressions</li> <li>Leverages SQLAlchemy's query optimization</li> <li>Supports database-specific optimizations</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#real-world-examples","title":"Real-World Examples","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#simple-and-condition","title":"Simple AND Condition","text":"<pre><code># Method: find_by_name_and_email\n# Generated SQL: SELECT * FROM user WHERE name = ? AND email = ?\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#simple-or-condition","title":"Simple OR Condition","text":"<pre><code># Method: find_by_status_or_age\n# Generated SQL: SELECT * FROM user WHERE status = ? OR age = ?\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#complex-mixed-conditions","title":"Complex Mixed Conditions","text":"<pre><code># Method: find_by_name_and_email_or_status_and_age\n# Generated SQL: SELECT * FROM user WHERE (name = ? AND email = ?) OR (status = ? AND age = ?)\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#multiple-or-conditions","title":"Multiple OR Conditions","text":"<pre><code># Method: find_by_name_or_email_or_status\n# Generated SQL: SELECT * FROM user WHERE name = ? OR email = ? OR status = ?\n</code></pre>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#integration-with-pyspringmodel","title":"Integration with PySpringModel","text":"<p>This algorithm is used by the <code>CrudRepositoryImplementationService</code> to:</p> <ol> <li>Parse Method Names: Extract field names and boolean operators</li> <li>Generate SQL: Create type-safe SQLAlchemy expressions</li> <li>Execute Queries: Run the generated queries with proper parameter binding</li> <li>Return Results: Handle single results (<code>Optional[Model]</code>) or multiple results (<code>List[Model]</code>)</li> </ol>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#best-practices","title":"Best Practices","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#method-naming","title":"Method Naming","text":"<ul> <li>Use clear, descriptive field names</li> <li>Follow the established naming conventions</li> <li>Keep method names readable and logical</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#parameter-types","title":"Parameter Types","text":"<ul> <li>Ensure parameter types match model field types</li> <li>Use appropriate data types for database columns</li> <li>Handle null values appropriately</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#query-complexity","title":"Query Complexity","text":"<ul> <li>For simple queries, use dynamic method names</li> <li>For complex queries, use custom SQL with <code>@Query</code> decorator</li> <li>Consider performance implications for large datasets</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#limitations","title":"Limitations","text":""},{"location":"guide/pyspring-model/sql-statement-algorithm/#current-limitations","title":"Current Limitations","text":"<ul> <li>Only supports AND and OR operators</li> <li>No support for NOT, XOR, or other boolean operators</li> <li>Limited to equality comparisons (no &lt;, &gt;, LIKE, etc.)</li> <li>No support for complex expressions or subqueries</li> </ul>"},{"location":"guide/pyspring-model/sql-statement-algorithm/#conclusion","title":"Conclusion","text":"<p>This dynamic query generation mechanism empowers developers to write clean, maintainable repository code without sacrificing the expressiveness or performance of SQL. By leveraging naming conventions and a structured parsing approach, PySpringModel minimizes boilerplate and maximizes flexibility.</p>"},{"location":"guide/scheduling/scheduler/","title":"PySpring Scheduler","text":"<p>The PySpring Scheduler provides a robust and flexible way to manage scheduled tasks in your applications, seamlessly integrating with the PySpring framework.</p>"},{"location":"guide/scheduling/scheduler/#installation","title":"Installation","text":"<p>Since the package is under active development, it can only be installed directly from the git repository:</p> <pre><code>pip install git+ssh://git@github.com/PythonSpring/pyspring-scheduler.git\n</code></pre>"},{"location":"guide/scheduling/scheduler/#overview","title":"Overview","text":"<p>The scheduler is built on top of APScheduler and provides a component-based approach to scheduling tasks. It supports various trigger types, timezone-aware scheduling, and integrates with PySpring's dependency injection system.</p>"},{"location":"guide/scheduling/scheduler/#configuration","title":"Configuration","text":"<p>The scheduler can be configured through your application's properties file:</p> <pre><code>{\n    \"scheduler\": {\n        \"number_of_workers\": 20,\n        \"max_instances\": 3,\n        \"timezone\": \"UTC\",\n        \"coalesce\": false\n    }\n}\n</code></pre>"},{"location":"guide/scheduling/scheduler/#configuration-options","title":"Configuration Options","text":"<ul> <li><code>number_of_workers</code>: Number of threads in the scheduler's thread pool</li> <li><code>max_instances</code>: Maximum number of concurrent instances of a job</li> <li><code>timezone</code>: Default timezone for all jobs</li> <li><code>coalesce</code>: Whether to run missed jobs when the scheduler resumes</li> </ul>"},{"location":"guide/scheduling/scheduler/#setting-up-the-scheduler","title":"Setting Up the Scheduler","text":"<ol> <li>Add the scheduler provider to your application:</li> </ol> <pre><code>from py_spring_core import PySpringApplication\nfrom py_spring_scheduler import provide_scheduler\n\ndef main():\n    app = PySpringApplication(\"./app-config.json\", entity_providers=[provide_scheduler()])\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guide/scheduling/scheduler/#creating-scheduled-tasks","title":"Creating Scheduled Tasks","text":""},{"location":"guide/scheduling/scheduler/#using-the-scheduled-decorator","title":"Using the @Scheduled Decorator","text":"<p>The <code>@Scheduled</code> decorator is the primary way to create scheduled tasks. It supports multiple trigger types:</p>"},{"location":"guide/scheduling/scheduler/#interval-trigger","title":"Interval Trigger","text":"<pre><code>from py_spring_scheduler import Scheduled, IntervalTrigger\n\n@Scheduled(trigger=IntervalTrigger(seconds=5))\ndef my_interval_task():\n    # Runs every 5 seconds\n    pass\n</code></pre>"},{"location":"guide/scheduling/scheduler/#cron-trigger","title":"Cron Trigger","text":"<pre><code>from py_spring_scheduler import Scheduled, CronTrigger\n\n@Scheduled(trigger=CronTrigger(cron=\"0 0 * * *\"))\ndef my_cron_task():\n    # Runs daily at midnight\n    pass\n</code></pre>"},{"location":"guide/scheduling/scheduler/#combining-triggers","title":"Combining Triggers","text":"<p>You can combine multiple triggers using <code>AndTrigger</code> and <code>OrTrigger</code>:</p> <pre><code>from py_spring_scheduler import Scheduled, IntervalTrigger, CronTrigger, AndTrigger, OrTrigger\n\n# Using OrTrigger (runs if either trigger condition is met)\n@Scheduled(trigger=OrTrigger([\n    IntervalTrigger(seconds=3),\n    CronTrigger(minute=0)\n]))\ndef my_or_task():\n    # Runs every 3 seconds OR at the start of every hour\n    pass\n\n# Using AndTrigger (runs only if all trigger conditions are met)\n@Scheduled(trigger=AndTrigger([\n    CronTrigger(hour=9),  # Only during 9 AM\n    CronTrigger(minute=0)  # Only at minute 0\n]))\ndef my_and_task():\n    # Runs only at 9:00 AM\n    pass\n</code></pre>"},{"location":"guide/scheduling/scheduler/#component-based-scheduling","title":"Component-based Scheduling","text":"<p>Scheduled tasks can be defined within PySpring components, allowing you to leverage dependency injection:</p> <pre><code>from py_spring_core import Component\nfrom py_spring_scheduler import Scheduled, IntervalTrigger\n\nclass MyComponent(Component):\n    @Scheduled(trigger=IntervalTrigger(seconds=3))\n    def scheduled_method(self):\n        # Runs every 3 seconds\n        pass\n</code></pre>"},{"location":"guide/scheduling/scheduler/#using-dependencies-in-scheduled-tasks","title":"Using Dependencies in Scheduled Tasks","text":"<p>Components can be injected and used within scheduled tasks:</p> <pre><code>from py_spring_core import Component\nfrom py_spring_scheduler import Scheduled, IntervalTrigger\n\nclass Service(Component):\n    def do_something(self):\n        print(\"Service method called\")\n\nclass TaskComponent(Component):\n    service: Service  # Dependency injection\n\n    @Scheduled(trigger=IntervalTrigger(seconds=5))\n    def scheduled_task(self):\n        self.service.do_something()\n</code></pre>"},{"location":"guide/scheduling/scheduler/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Resource Management</p> <ul> <li>Set appropriate <code>max_instances</code> to prevent resource exhaustion</li> <li>Use <code>coalesce</code> carefully to avoid overwhelming the system after downtime</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Implement proper error handling in scheduled tasks</li> <li>Consider using PySpring's logging system for task monitoring</li> </ul> </li> <li> <p>Timezone Awareness</p> <ul> <li>Always specify timezones explicitly for cron jobs</li> <li>Be mindful of daylight saving time transitions</li> </ul> </li> <li> <p>Component Design</p> <ul> <li>Keep scheduled tasks focused and single-purpose</li> <li>Use dependency injection for better testability</li> </ul> </li> </ol>"},{"location":"guide/scheduling/scheduler/#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>Periodic Data Processing <pre><code>@Scheduled(trigger=IntervalTrigger(minutes=30))\ndef process_data():\n    # Process data every 30 minutes\n    pass\n</code></pre></p> </li> <li> <p>Daily Maintenance Tasks <pre><code>@Scheduled(trigger=CronTrigger(cron=\"0 2 * * *\"))  # 2 AM daily\ndef maintenance_task():\n    # Perform daily maintenance\n    pass\n</code></pre></p> </li> <li> <p>Health Checks <pre><code>@Scheduled(trigger=IntervalTrigger(minutes=5))\ndef health_check():\n    # Check system health every 5 minutes\n    pass\n</code></pre></p> </li> </ol>"},{"location":"guide/scheduling/scheduler/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/scheduling/scheduler/#common-issues","title":"Common Issues","text":"<ol> <li>Tasks Not Running</li> <li>Check if the scheduler is properly initialized</li> <li>Verify timezone settings</li> <li> <p>Ensure the task is properly decorated</p> </li> <li> <p>Resource Exhaustion</p> </li> <li>Monitor thread pool usage</li> <li>Adjust <code>number_of_workers</code> based on workload</li> <li> <p>Review <code>max_instances</code> settings</p> </li> <li> <p>Timezone Issues</p> </li> <li>Verify timezone configuration</li> <li>Check for daylight saving time transitions</li> <li>Use explicit timezone settings in triggers</li> </ol>"},{"location":"guide/scheduling/scheduler/#summary","title":"Summary","text":"<p>The PySpring Scheduler provides:</p> <ul> <li>Seamless integration with PySpring framework</li> <li>Flexible scheduling options (Interval, Cron)</li> <li>Component-based task management</li> <li>Dependency injection support</li> <li>Configurable thread pool</li> <li>Timezone-aware scheduling</li> <li>Job coalescing and instance limits</li> </ul> <p>By following the patterns and best practices outlined in this guide, you can effectively implement scheduled tasks in your PySpring applications. </p>"}]}