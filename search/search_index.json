{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySpring Framework","text":""},{"location":"#overview","title":"Overview","text":"<p>PySpring is a Python web framework inspired by Spring Boot. It provides a structured approach to building scalable web applications with key features like:</p> <ul> <li>Auto Dependency Injection</li> <li>Auto Configuration Management</li> <li>ASGI Web Server for hosting your application</li> </ul>"},{"location":"#technologies-used-in-pyspring","title":"Technologies Used in PySpring","text":"<ul> <li>FastAPI: For the web server layer.</li> </ul> <ul> <li>Pydantic: For data validation.</li> </ul> <p>PySpring combines these technologies to deliver a seamless development experience for building modern, scalable applications.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Application Initialization: PySpringApplication class serves as the main entry point for the PySpring application. It initializes the application from a configuration file, scans the application source directory for Python files, and groups them into class files and model files</p> </li> <li> <p>Model Import and Table Creation: PySpring dynamically imports model modules and creates SQLModel tables based on the imported models. It supports SQLAlchemy for database operations.</p> </li> <li> <p>Application Context Management: PySpring manages the application context and dependency injection. It registers application entities such as components, controllers, bean collections, and properties. It also initializes the application context and injects dependencies.</p> </li> <li> <p>REST Controllers: PySpring supports RESTful API development using the RestController class. It allows you to define routes, handle HTTP requests, and register middlewares easily.</p> </li> <li> <p>Component-based Architecture: PySpring encourages a component-based architecture, where components are reusable and modular building blocks of the application. Components can have their own lifecycle and can be registered and managed by the application context.</p> </li> <li> <p>Properties Management: Properties classes provide a convenient way to manage application-specific configurations. PySpring supports loading properties from a properties file and injecting them into components.</p> </li> <li> <p>Framework Modules: PySpring allows the integration of additional framework modules to extend the functionality of the application. Modules can provide additional routes, middlewares, or any other custom functionality required by the application.</p> </li> <li> <p>Builtin FastAPI Integration: PySpring integrates with <code>FastAPI</code>, a modern, fast (high-performance), web framework for building APIs with Python. It leverages FastAPI's features for routing, request handling, and server configuration.</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with PySpring, follow these steps:</p> <ol> <li>Install the PySpring framework by running:</li> </ol> <pre><code>pip3 install py-spring-core\n</code></pre> <ol> <li> <p>Create a new Python project and navigate to its directory</p> </li> <li> <p>Implement your application properties, components, controllers, using PySpring conventions inside declared source code folder (whcih can be modified the key <code>app_src_target_dir</code> inside app-config.json), this controls what folder will be scanned by the framework.</p> </li> <li> <p>Instantiate a <code>PySpringApplication</code> object in your main script, passing the path to your application configuration file.</p> </li> <li> <p>Optionally, define and enable any framework modules you want to use.</p> </li> <li> <p>Run the application by calling the <code>run()</code> method on the <code>PySpringApplication</code> object, as shown in the example code below:</p> </li> </ol> <pre><code>from py_spring_core import PySpringApplication\n\ndef main():\n    app = PySpringApplication(\"./app-config.json\")\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li>For example project, please refer to this github repo.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to PySpring are welcome! If you find any issues or have suggestions for improvements, please submit a pull request or open an issue on GitHub.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/","title":"Auto Dependency Injection","text":""},{"location":"guide/dependency-injection/auto-deppendency-injection/#dependency-injection","title":"Dependency Injection","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/","title":"Dependency Injection (DI)","text":"<p>Dependency Injection (DI) is a design pattern and a fundamental concept in software engineering. It is a technique where an object (or function) receives its dependencies from an external source rather than creating them itself. This approach promotes loose coupling between components, making the code more modular, testable, and maintainable.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#core-concepts","title":"Core Concepts","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-dependency","title":"1. Dependency","text":"<p>A dependency is any object or service that another object requires to function. For example, a <code>Service</code> class might rely on a <code>Repository</code> class to fetch data.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-injection","title":"2. Injection","text":"<p>Injection refers to the process of providing the dependency to the object that needs it. This is usually handled by a DI container or framework.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#types-of-dependency-injection","title":"Types of Dependency Injection","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-constructor-injection","title":"1. Constructor Injection","text":"<p>Dependencies are provided through the constructor of the dependent class.</p> <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service(repo)\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-setter-injection","title":"2. Setter Injection","text":"<p>Dependencies are provided through a setter method after the object is constructed. <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def set_repository(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service()\nservice.set_repository(repo)\nprint(service.get_data())\n</code></pre></p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#benefits-of-dependency-injection","title":"Benefits of Dependency Injection","text":"<ul> <li> <p>Loose Coupling: Classes are decoupled from their dependencies, making them easier to modify and extend.</p> </li> <li> <p>Improved Testability: Dependencies can be replaced with mock objects, facilitating unit testing.</p> </li> <li> <p>Easier Maintenance: Changes to a dependency's implementation do not affect the dependent classes.</p> </li> <li> <p>Reusability: Components are more reusable because they do not rely on specific implementations.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#challenges-without-dependency-injection","title":"Challenges Without Dependency Injection","text":"<p>Without DI, objects are responsible for creating their own dependencies, which can lead to several issues:</p> <ul> <li> <p>Tight Coupling Classes directly instantiate their dependencies, making them tightly coupled. This means any change in the dependency's implementation requires changes in the dependent class.</p> </li> <li> <p>Reduced Testability Since dependencies are hard-coded, it becomes challenging to replace them with mock objects during testing, complicating unit testing efforts.</p> </li> <li> <p>Limited Reusability Components become less reusable because they are bound to specific implementations rather than abstractions.</p> </li> <li> <p>Complex Maintenance With dependencies directly embedded, managing and updating dependencies becomes more difficult, leading to potential code duplication and increased maintenance overhead.</p> </li> <li> <p>Violation of the Single Responsibility Principle When classes manage their own dependencies, they take on additional responsibilities beyond their primary purpose, violating the Single Responsibility Principle and reducing code clarity.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#example-without-dependency-injection","title":"Example Without Dependency Injection","text":"<pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self):\n        # Directly creating the dependency inside the class\n        self.repository = Repository()\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\n# Usage\nservice = Service()\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#problems-in-the-code","title":"Problems in the Code","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-tight-coupling","title":"1. Tight Coupling","text":"<ul> <li>The <code>Service</code> class directly creates an instance of the <code>Repository</code> class in its constructor. This means the <code>Service</code> class is tightly coupled to the <code>Repository</code> class.</li> <li>If you wanted to change the data source, for example, switching from a <code>Repository</code> to an <code>ApiRepository</code>, you would need to modify the <code>Service</code> class. This breaks the principle of loose coupling.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-reduced-testability","title":"2. Reduced Testability","text":"<ul> <li>In this setup, unit testing becomes difficult because we can't replace the <code>Repository</code> with a mock or a stub.</li> <li>The <code>Service</code> class always depends on a real instance of the <code>Repository</code> class, making tests harder to isolate and slower to run.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#3-limited-reusability","title":"3. Limited Reusability","text":"<ul> <li>The <code>Service</code> class is not reusable with different kinds of repositories. </li> <li>If you wanted to use the <code>Service</code> class with a different repository implementation, you'd have to modify the <code>Service</code> class itself. This is not flexible and goes against the idea of creating reusable components.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#4-complex-maintenance","title":"4. Complex Maintenance","text":"<ul> <li>As the application grows and more dependencies are added to the <code>Service</code> class, it becomes more difficult to manage.</li> <li>If every class is responsible for creating its own dependencies, the codebase becomes harder to maintain, leading to potential code duplication and tightly coupled components.</li> </ul>"},{"location":"guide/entities-in-framework/component/","title":"Component","text":"<p>The <code>Component</code> class in PySpring serves as the foundational building block for creating modular, reusable functionalities. It supports lifecycle management, dependency injection, and property configuration, making it an essential entity in the PySpring framework.</p>"},{"location":"guide/entities-in-framework/component/#overview","title":"Overview","text":"<p>The <code>Component</code> class encapsulates specific functionalities and enables seamless integration with the PySpring application context. It is highly configurable, allowing developers to define scope, inject dependencies, and manage lifecycle hooks.</p>"},{"location":"guide/entities-in-framework/component/#features","title":"Features","text":"<ol> <li> <p>Reusability and Modularity    Components are designed to be reusable and modular, encapsulating specific functionalities that can be leveraged across the application.</p> </li> <li> <p>Scope Management     The scope determines whether the component instance is shared (<code>Singleton</code>) or created a new each time (<code>Prototype</code>),  which can be configured using the <code>ComponentScope</code> enum.  </p> <ul> <li><code>Singleton</code>: Single shared instance throughout the application.  </li> <li><code>Prototype</code>: A new instance is created per request.</li> </ul> </li> <li> <p>Lifecycle Hooks    Components provide hooks for initialization and destruction:  </p> <ul> <li><code>post_construct()</code>: Invoked after the component is initialized.  </li> <li><code>pre_destroy()</code>: Invoked before the component is destroyed.</li> </ul> </li> <li> <p>Dependency Injection    Components can be declare as dependencies for being injected to other components by the PySpring framework.</p> </li> <li> <p>Properties Injection    Properties from configuration files can be injected into components to simplify configuration management.</p> </li> </ol>"},{"location":"guide/entities-in-framework/component/#configuration","title":"Configuration","text":""},{"location":"guide/entities-in-framework/component/#nested-config-class","title":"Nested <code>Config</code> Class","text":"<p>The <code>Component</code> class includes a nested <code>Config</code> class to define configuration options, such as:  </p> <ul> <li>Allowed scope (<code>Singleton</code> or <code>Prototype</code>).</li> </ul>"},{"location":"guide/entities-in-framework/component/#methods","title":"Methods","text":""},{"location":"guide/entities-in-framework/component/#lifecycle-methods","title":"Lifecycle Methods","text":"<ul> <li><code>post_construct()</code>:     Called after initialization to set up the component. Subclasses can override this method.</li> <li><code>pre_destroy()</code>:     Called before destruction for cleanup. Subclasses can override this method.</li> <li><code>finish_initialization_cycle()</code>:     Invokes <code>post_construct()</code> and finalizes initialization.</li> <li><code>finish_destruction_cycle()</code>:     Invokes <code>pre_destroy()</code> and finalizes destruction.</li> </ul>"},{"location":"guide/entities-in-framework/component/#scope-management","title":"Scope Management","text":"<ul> <li><code>get_scope()</code>:   Returns the current scope of the component (<code>Singleton</code> or <code>Prototype</code>).</li> <li><code>set_scope(scope: ComponentScope)</code>:   Sets the scope of the component.</li> </ul>"},{"location":"guide/entities-in-framework/component/#usage-example","title":"Usage Example","text":"<pre><code>from py_spring_core import Component, ComponentScope\n\nclass MyComponent(Component):\n    class Config:\n        scope = ComponentScope.Singleton\n\n    def post_construct(self):\n        print(\"Component initialized.\")\n\n    def pre_destroy(self):\n        print(\"Component about to be destroyed.\")\n</code></pre>"},{"location":"guide/entities-in-framework/properties/","title":"Properties","text":"<p>The <code>Properties</code> class in PySpring provides a way to manage application-specific configurations. It allows you to load properties from a file and inject them into components.</p>"},{"location":"guide/entities-in-framework/properties/#key-features","title":"Key Features","text":"<ul> <li>Configuration Management:  <code>Properties</code> classes provide a structured way to manage application settings. They are loaded from a properties file, typically in JSON or YAML format.</li> <li>Unique Identifiers: Each <code>Properties</code> class has a unique key (<code>__key__</code>) that is used to identify it within the application. This key must be set as a class-level attribute in your <code>Properties</code> subclass.</li> <li>Automatic Loading and Injection: PySpring automatically loads properties during the application initialization process and injects them into components where they are needed.</li> <li>File Format Support: Properties can be loaded from JSON or YAML files. The <code>_PropertiesLoader</code> class handles the parsing of these files.</li> <li>Validation: The <code>Properties</code> class uses <code>Pydantic</code> for data validation. This ensures that the loaded properties conform to the expected schema.</li> <li>Singleton Scope: Properties are typically loaded as singletons within the application context and are shared across the application.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-to-define-properties","title":"How to Define Properties","text":"<p>To define your properties, you need to create a class that inherits from <code>Properties</code> and set the <code>__key__</code> class variable . This key must be a unique string that will be used to identify this <code>Properties</code> class.</p> <pre><code>from py_spring_core import Properties\nfrom pydantic import Field\n\nclass AppConfigProperties(Properties):\n    __key__ = \"app_config\" # Unique key for this properties class\n    app_name: str\n    version: str = Field(default=\"0.1.0\")\n    log_level: str = \"INFO\"\n</code></pre> <p>In the above example:</p> <ul> <li><code>AppConfigProperties</code> inherits from the base <code>Properties</code> class.</li> <li><code>__key__</code> is set to <code>\"app_config\"</code>, which is used to identify this specific set of properties.</li> <li><code>app_name</code>, <code>version</code>, and <code>log_level</code> are properties defined using Pydantic's field syntax.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-properties-are-loaded","title":"How Properties are Loaded","text":"<p>The <code>_PropertiesLoader</code> class is used to load properties from a file.</p> <ol> <li>During application startup, the <code>PySpringApplication</code> initializes an <code>ApplicationContext</code> that loads the properties.</li> <li>The application scans for all classes that inherit from <code>Properties</code>.</li> <li>The properties file path is defined in the application config (e.g., <code>./application-properties.json</code> or <code>./application-properties.yaml</code>).</li> <li>The loader attempts to read and parse the file based on its extension (<code>.json</code>, <code>.yaml</code>, or <code>.yml</code>).</li> <li>The loader validates the properties against the classes that inherit from <code>Properties</code>, ensuring the keys match what has been defined in the application, and raises an error if validation fails.</li> <li>Once loaded, the properties are stored in the <code>ApplicationContext</code> and are accessible for dependency injection.</li> </ol>"},{"location":"guide/entities-in-framework/properties/#how-to-use-properties","title":"How to Use Properties","text":""},{"location":"guide/entities-in-framework/properties/#dependency-injection","title":"Dependency Injection","text":"<p>Once properties are loaded, you can inject them into your components using type annotations.</p> <p><pre><code>from py_spring_core import Component, Properties\nfrom .app_config_properties import AppConfigProperties\n\nclass MyComponent(Component):\n    app_config: AppConfigProperties\n\n    def post_construct(self):\n        print(f\"App Name: {self.app_config.app_name}\")\n        print(f\"Log Level: {self.app_config.log_level}\")`\n</code></pre> In this example:</p> <ul> <li>The <code>MyComponent</code> class has a type annotation <code>app_config: AppConfigProperties</code>, where <code>AppConfigProperties</code> is the properties class defined above.</li> <li>The application context automatically injects an instance of <code>AppConfigProperties</code> into the <code>app_config</code> attribute of the <code>MyComponent</code> instance.</li> <li>The properties can then be accessed within the <code>MyComponent</code>'s methods.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#accessing-properties-directly","title":"Accessing Properties Directly","text":"<p>You can also access properties directly from the <code>_PropertiesLoader</code> if needed. Note, this is typically not necessary if you are using dependency injection.</p> <pre><code>from py_spring_core.core.entities.properties.properties_loader import _PropertiesLoader\n\napp_config = _PropertiesLoader.get_properties(\"app_config\")\n\nif app_config:\n    print(f\"Direct access: App Name: {app_config.app_name}\")`\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#configuration-file-examples","title":"Configuration File Examples","text":""},{"location":"guide/entities-in-framework/properties/#json","title":"JSON","text":"<p>A JSON properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass.</p> <pre><code>{\n  \"app_config\": {\n    \"app_name\": \"My Cool App\",\n    \"version\": \"1.2.3\",\n    \"log_level\": \"DEBUG\"\n  }\n}\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#yaml","title":"YAML","text":"<p>A YAML properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass. <pre><code>app_config:\n  app_name: My Cool App\n  version: 1.2.3\n  log_level: DEBUG`\n</code></pre></p>"},{"location":"guide/entities-in-framework/properties/#important-considerations","title":"Important Considerations","text":"<ul> <li>Key Uniqueness: Ensure that each <code>Properties</code> class has a unique <code>__key__</code> to avoid conflicts.</li> <li>File Path: The properties file path must be correctly configured in the application's configuration file.</li> <li>File Format: PySpring supports both JSON and YAML formats for properties files.</li> <li>Validation: Ensure that your properties files match the structure defined in your <code>Properties</code> classes. Pydantic will enforce data types and raise errors if there are mismatches.</li> <li>Dependency Injection: For loose coupling, use dependency injection to make your properties available to components, which is typically preferred over directly accessing properties from <code>_PropertiesLoader</code>.</li> <li>Error Handling: Be aware of the exceptions that can be raised during properties loading, such as <code>InvalidPropertiesKeyError</code>, and <code>TypeError</code> if the properties are not found or are not properly configured.</li> </ul> <p>By using the <code>Properties</code> class, you can effectively manage your application's configurations in a structured and maintainable way.</p>"},{"location":"guide/entities-in-framework/rest-controller/","title":"RestController","text":"<p>The <code>RestController</code> class in PySpring serves as a base class for building RESTful API controllers. It provides a structured way to define API endpoints, handle HTTP requests, and manage middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#key-features","title":"Key Features","text":"<ol> <li>Base Class: Acts as a base class that should be extended for creating specific controllers.</li> <li>Routing: Provides a mechanism to register routes using FastAPI's routing capabilities.</li> <li>Middleware Support: Allows registration of middleware for pre- and post-request processing.</li> <li>FastAPI Integration: Leverages FastAPI's features for building high-performance APIs.</li> <li>Configuration: Supports configuration of the base URL prefix for controller routes.</li> <li>Automatic Registration: Automatically integrates controllers with the application context and FastAPI during initialization.</li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#how-to-define-a-restcontroller","title":"How to Define a RestController","text":""},{"location":"guide/entities-in-framework/rest-controller/#create-a-controller-class","title":"Create a Controller Class","text":"<p>Extend the <code>RestController</code> class and override the <code>register_routes()</code> method to define routes. Optionally, override <code>register_middlewares()</code> to add middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#example","title":"Example:","text":"<pre><code>from py_spring_core import RestController\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\nclass MyController(RestController):\n    class Config:\n        prefix = \"/api/items\"  # Base URL prefix for this controller\n\n    def register_routes(self):\n        @self.router.get(\"/\")\n        def read_items():\n            return {\"message\": \"List of items\"}\n\n        @self.router.get(\"/{item_id}\")\n        def read_item(item_id: int):\n            return {\"message\": f\"Details for item {item_id}\"}\n\n        @self.router.post(\"/\", status_code=201)\n        def create_item(item: Item):\n            return item\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#key-points","title":"Key Points:","text":"<ul> <li>Use the <code>Config</code> inner class to set the route prefix.</li> <li>Define routes using the <code>@self.router</code> decorator.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#automatic-registration-process","title":"Automatic Registration Process","text":"<ol> <li>During application startup, PySpring scans for classes inheriting from <code>RestController</code>.</li> <li>The <code>_handle_register_rest_controller()</code> method:<ul> <li>Registers the controller with the application context.</li> <li>Initializes an <code>APIRouter</code> instance.</li> <li>Calls <code>register_routes()</code> to add routes.</li> <li>Includes the controller's router in the main FastAPI application.</li> <li>Calls <code>register_middlewares()</code> for middleware registration.</li> </ul> </li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#defining-routes","title":"Defining Routes","text":"<p>Use <code>@self.router</code> decorators to define API endpoints inside <code>register_routes()</code>:</p> <pre><code>@self.router.get(\"/\")\ndef read_items():\n    return {\"message\": \"List of items\"}\n\n@self.router.post(\"/\", status_code=201)\ndef create_item(item: Item):\n    return item\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#example_1","title":"Example:","text":"<ul> <li><code>GET /</code> maps to the <code>read_items</code> method.</li> <li><code>POST /</code> maps to the <code>create_item</code> method.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#fastapi-features","title":"FastAPI Features:","text":"<ul> <li>Dependency Injection</li> <li>Request body handling</li> <li>Path parameter parsing</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#defining-middlewares","title":"Defining Middlewares","text":"<p>Override <code>register_middlewares()</code> to add middleware. Use <code>app.middleware()</code> to define custom middleware functions.</p>"},{"location":"guide/entities-in-framework/rest-controller/#example_2","title":"Example:","text":"<pre><code>def register_middlewares(self):\n    @self.app.middleware(\"http\")\n    async def add_process_time_header(request, call_next):\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n        response.headers[\"X-Process-Time\"] = str(process_time)\n        return response\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#common-middleware-use-cases","title":"Common Middleware Use Cases:","text":"<ul> <li>Authentication</li> <li>Authorization</li> <li>Logging</li> <li>Performance metrics</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#accessing-fastapi-components","title":"Accessing FastAPI Components","text":"<ul> <li><code>self.app</code>: The main FastAPI application instance.</li> <li><code>self.router</code>: The APIRouter instance for the controller.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#important-considerations","title":"Important Considerations","text":"<ol> <li>Class Configuration: Use the <code>Config</code> class to define the URL prefix.</li> <li>Route Registration: Ensure all routes are defined in <code>register_routes()</code> using <code>@self.router</code>.</li> <li>Middleware Registration: Add middleware in <code>register_middlewares()</code> using <code>app.middleware()</code>.</li> <li>Dependency Injection: In this class, you can leverage both PySpring's and FastAPI's dependency injection systems to manage dependencies efficiently.</li> <li>Error Handling: Use <code>HTTPException</code> for proper error responses and integrate with PySpring's error handling mechanisms.</li> <li>Code Organization: Keep controllers focused on request handling and delegate business logic to services or components.</li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#summary","title":"Summary","text":"<p>The <code>RestController</code> class helps build well-structured, maintainable, and scalable RESTful APIs in PySpring. By utilizing its features like routing, middleware support, and integration with FastAPI, developers can focus on creating efficient APIs while maintaining code clarity and modularity.</p>"}]}