{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySpring Framework","text":""},{"location":"#overview","title":"Overview","text":"<p>PySpring is a Python web framework inspired by Spring Boot. It provides a structured approach to building scalable web applications with key features like:</p> <ul> <li>Auto Dependency Injection</li> <li>Auto Configuration Management</li> <li>ASGI Web Server for hosting your application</li> </ul>"},{"location":"#technologies-used-in-pyspring","title":"Technologies Used in PySpring","text":"<ul> <li>FastAPI: For the web server layer.</li> <li>Pydantic: For data validation.</li> </ul> <p>PySpring combines these technologies to deliver a seamless development experience for building modern, scalable applications.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Application Initialization: PySpringApplication class serves as the main entry point for the PySpring application. It initializes the application from a configuration file, scans the application source directory for Python files, and groups them into class files and model files</p> </li> <li> <p>Application Context Management: PySpring manages the application context and dependency injection. It registers application entities such as components, controllers, bean collections, and properties. It also initializes the application context and injects dependencies.</p> </li> <li> <p>REST Controllers: PySpring supports RESTful API development using the RestController class. It allows you to define routes, handle HTTP requests, and register middlewares easily.</p> </li> <li> <p>Component-based Architecture: PySpring encourages a component-based architecture, where components are reusable and modular building blocks of the application. Components can have their own lifecycle and can be registered and managed by the application context.</p> </li> <li> <p>Properties Management: Properties classes provide a convenient way to manage application-specific configurations. PySpring supports loading properties from a properties file and injecting them into components.</p> </li> <li> <p>Framework Modules: PySpring allows the integration of additional framework modules to extend the functionality of the application. Modules can provide additional routes, middlewares, or any other custom functionality required by the application.</p> </li> <li> <p>Builtin FastAPI Integration: PySpring integrates with <code>FastAPI</code>, a modern, fast (high-performance), web framework for building APIs with Python. It leverages FastAPI's features for routing, request handling, and server configuration.</p> </li> <li> <p>OpenAPI Generation: Since PySpring leverages <code>FastAPI</code>, it automatically generates OpenAPI documentation for the application. The API routes, endpoints, and data models are used to create interactive, self-updating OpenAPI documentation, which can be easily accessed via FastAPI's built-in web interface.</p> </li> <li> <p>Type-Safety: The framework is type-safe when used properly. All dependency injection (DI) is determined based on Python type hints, ensuring that dependencies are injected in a consistent and reliable manner. This feature enables better development practices by reducing runtime errors and improving code clarity.</p> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with PySpring, follow these steps:</p> <ol> <li>Install the PySpring framework by running:</li> </ol> <pre><code>pip3 install py-spring-core\n</code></pre> <ol> <li> <p>Create a new Python project and navigate to its directory</p> </li> <li> <p>Implement your application properties, components, controllers, using PySpring conventions inside declared source code folder (whcih can be modified the key <code>app_src_target_dir</code> inside app-config.json), this controls what folder will be scanned by the framework.</p> </li> <li> <p>Instantiate a <code>PySpringApplication</code> object in your main script, passing the path to your application configuration file.</p> </li> <li> <p>Optionally, define and enable any framework modules you want to use.</p> </li> <li> <p>Run the application by calling the <code>run()</code> method on the <code>PySpringApplication</code> object, as shown in the example code below:</p> </li> </ol> <pre><code>from py_spring_core import PySpringApplication\n\ndef main():\n    app = PySpringApplication(\"./app-config.json\")\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li>For example project, please refer to this github repo.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to PySpring are welcome! If you find any issues or have suggestions for improvements, please submit a pull request or open an issue on GitHub.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/","title":"Dependency Injection with Entities in PySpring","text":"<p>PySpring's dependency injection (DI) system simplifies dependency management, improves code modularity, and promotes loose coupling between application entities. This guide covers how to use PySpring's DI system to integrate components and other application entities.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#key-features-of-pysprings-di-system","title":"Key Features of PySpring's DI System","text":""},{"location":"guide/dependency-injection/auto-deppendency-injection/#1-declaring-dependencies","title":"1. Declaring Dependencies","text":"<p>To inject a dependency into a component, declare an attribute with a type hint for the required dependency. PySpring automatically resolves and injects the required dependency during application initialization.</p> <p>Example:</p> <pre><code>class ExampleService:\n    example_properties: ExampleProperties\n</code></pre> <p>Here, the <code>ExampleService</code> component declares a dependency on <code>ExampleProperties</code> by defining the <code>example_properties</code> attribute with the appropriate type annotation.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#2-automatic-resolution","title":"2. Automatic Resolution","text":"<p>During initialization, PySpring's <code>ApplicationContext</code> automatically scans declared dependencies, resolves them, and injects the corresponding instances.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#how-it-works","title":"How It Works:","text":"<ul> <li> <p>When a component is instantiated, the <code>_inject_entity_dependencies</code> method of the <code>ApplicationContext</code> is called.</p> </li> <li> <p>If the dependency is a <code>Properties</code> class, the system retrieves the properties from the application context using the key defined in the <code>Properties</code> class.</p> </li> <li> <p>If the dependency is not a <code>Properties</code> class, the system retrieves it from the component or bean collection using <code>get_component</code> or <code>get_bean</code>.</p> </li> <li> <p>If the dependency cannot be resolved, an error is raised.</p> </li> </ul> <p>Error Handling: If a dependency cannot be resolved, <code>_inject_entity_dependencies</code> raises a <code>ValueError</code> with a descriptive error message. This ensures early detection of misconfigured dependencies.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#3-accessing-injected-dependencies","title":"3. Accessing Injected Dependencies","text":"<p>Once injected, dependencies can be accessed directly using the declared attribute name.</p> <p>Example:</p> <pre><code>class ExampleService:\n    example_properties: ExampleProperties\n\n    def display_property(self):\n        print(self.example_properties.value)\n</code></pre> <p>Here, <code>example_properties</code> is automatically injected, and its value is accessed using <code>self.example_properties.value</code>.</p>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#4-component-lifecycle-methods","title":"4. Component Lifecycle Methods","text":"<p>PySpring supports lifecycle methods to manage component behavior:</p> <ul> <li> <p><code>**post_construct()**</code>: Called after dependencies are injected, allowing initialization with injected resources.</p> </li> <li> <p><code>**pre_destroy()**</code>: Called before the component is destroyed, enabling cleanup actions.</p> </li> </ul> <p>Example:</p> <pre><code>class ExampleService:\n    example_properties: ExampleProperties\n\n    def post_construct(self):\n        print(\"Component initialized with\", self.example_properties)\n\n    def pre_destroy(self):\n        print(\"Cleaning up ExampleService\")\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#5-supported-dependency-types","title":"5. Supported Dependency Types","text":"<p>PySpring's DI system supports injecting the following:</p> <ul> <li> <p>Component classes</p> </li> <li> <p>Properties classes</p> </li> <li> <p>Beans defined within a <code>BeanCollection</code></p> </li> </ul>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#practical-example","title":"Practical Example","text":"<p>Below is an example showcasing the DI system in action:</p> <pre><code>class ExampleProperties:\n    key: str\n    value: str\n\nclass ExampleService:\n    example_properties: ExampleProperties\n\n    def post_construct(self):\n        print(f\"Initialized with property: {self.example_properties.value}\")\n\n    def pre_destroy(self):\n        print(\"ExampleService is being cleaned up\")\n\nclass AnotherExampleService:\n    example_service: ExampleService\n\n    def post_construct(self):\n        print(\"AnotherExampleService initialized\")\n</code></pre>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#steps-in-dependency-injection","title":"Steps in Dependency Injection:","text":"<ol> <li> <p>Load Properties: <code>ExampleProperties</code> values are loaded from the application's properties file.</p> </li> <li> <p>Component Instantiation: An instance of <code>ExampleService</code> is created.</p> </li> <li> <p>Dependency Injection: The <code>example_properties</code> attribute of <code>ExampleService</code> is injected with the <code>ExampleProperties</code> instance.</p> </li> <li> <p>Another Component Instantiation: An instance of <code>AnotherExampleService</code> is created.</p> </li> <li> <p>Cross-Component Injection: The <code>example_service</code> attribute of <code>AnotherExampleService</code> is injected with the <code>ExampleService</code> instance.</p> </li> <li> <p>Lifecycle Methods: <code>post_construct</code> methods are called for both components.</p> </li> <li> <p>Cleanup: On application shutdown, the <code>pre_destroy</code> method of <code>ExampleService</code> is called.</p> </li> </ol>"},{"location":"guide/dependency-injection/auto-deppendency-injection/#summary","title":"Summary","text":"<p>PySpring's DI system provides:</p> <ul> <li> <p>Seamless Dependency Management: Automatically resolves and injects dependencies.</p> </li> <li> <p>Error Handling: Ensures misconfigurations are detected early.</p> </li> <li> <p>Lifecycle Support: Enables initialization and cleanup logic.</p> </li> <li> <p>Flexibility: Supports a wide range of dependency types, including components, properties, and beans.</p> </li> </ul> <p>By simply declaring dependencies using type hints, PySpring handles the resolution and injection, letting you focus on building modular, testable, and maintainable applications.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/","title":"Dependency Injection (DI)","text":"<p>Dependency Injection (DI) is a design pattern and a fundamental concept in software engineering. It is a technique where an object (or function) receives its dependencies from an external source rather than creating them itself. This approach promotes loose coupling between components, making the code more modular, testable, and maintainable.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#core-concepts","title":"Core Concepts","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-dependency","title":"1. Dependency","text":"<p>A dependency is any object or service that another object requires to function. For example, a <code>Service</code> class might rely on a <code>Repository</code> class to fetch data.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-injection","title":"2. Injection","text":"<p>Injection refers to the process of providing the dependency to the object that needs it. This is usually handled by a DI container or framework.</p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#types-of-dependency-injection","title":"Types of Dependency Injection","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-constructor-injection","title":"1. Constructor Injection","text":"<p>Dependencies are provided through the constructor of the dependent class.</p> <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service(repo)\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-setter-injection","title":"2. Setter Injection","text":"<p>Dependencies are provided through a setter method after the object is constructed. <pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def set_repository(self, repository: Repository):\n        self.repository = repository\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\nrepo = Repository()\nservice = Service()\nservice.set_repository(repo)\nprint(service.get_data())\n</code></pre></p>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#benefits-of-dependency-injection","title":"Benefits of Dependency Injection","text":"<ul> <li> <p>Loose Coupling: Classes are decoupled from their dependencies, making them easier to modify and extend.</p> </li> <li> <p>Improved Testability: Dependencies can be replaced with mock objects, facilitating unit testing.</p> </li> <li> <p>Easier Maintenance: Changes to a dependency's implementation do not affect the dependent classes.</p> </li> <li> <p>Reusability: Components are more reusable because they do not rely on specific implementations.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#challenges-without-dependency-injection","title":"Challenges Without Dependency Injection","text":"<p>Without DI, objects are responsible for creating their own dependencies, which can lead to several issues:</p> <ul> <li> <p>Tight Coupling Classes directly instantiate their dependencies, making them tightly coupled. This means any change in the dependency's implementation requires changes in the dependent class.</p> </li> <li> <p>Reduced Testability Since dependencies are hard-coded, it becomes challenging to replace them with mock objects during testing, complicating unit testing efforts.</p> </li> <li> <p>Limited Reusability Components become less reusable because they are bound to specific implementations rather than abstractions.</p> </li> <li> <p>Complex Maintenance With dependencies directly embedded, managing and updating dependencies becomes more difficult, leading to potential code duplication and increased maintenance overhead.</p> </li> <li> <p>Violation of the Single Responsibility Principle When classes manage their own dependencies, they take on additional responsibilities beyond their primary purpose, violating the Single Responsibility Principle and reducing code clarity.</p> </li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#example-without-dependency-injection","title":"Example Without Dependency Injection","text":"<pre><code>class Repository:\n    def fetch_data(self):\n        return \"Data from repository\"\n\nclass Service:\n    def __init__(self):\n        # Directly creating the dependency inside the class\n        self.repository = Repository()\n\n    def get_data(self):\n        return self.repository.fetch_data()\n\n# Usage\nservice = Service()\nprint(service.get_data())\n</code></pre>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#problems-in-the-code","title":"Problems in the Code","text":""},{"location":"guide/dependency-injection/what-is-denpendency-injection/#1-tight-coupling","title":"1. Tight Coupling","text":"<ul> <li>The <code>Service</code> class directly creates an instance of the <code>Repository</code> class in its constructor. This means the <code>Service</code> class is tightly coupled to the <code>Repository</code> class.</li> <li>If you wanted to change the data source, for example, switching from a <code>Repository</code> to an <code>ApiRepository</code>, you would need to modify the <code>Service</code> class. This breaks the principle of loose coupling.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#2-reduced-testability","title":"2. Reduced Testability","text":"<ul> <li>In this setup, unit testing becomes difficult because we can't replace the <code>Repository</code> with a mock or a stub.</li> <li>The <code>Service</code> class always depends on a real instance of the <code>Repository</code> class, making tests harder to isolate and slower to run.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#3-limited-reusability","title":"3. Limited Reusability","text":"<ul> <li>The <code>Service</code> class is not reusable with different kinds of repositories. </li> <li>If you wanted to use the <code>Service</code> class with a different repository implementation, you'd have to modify the <code>Service</code> class itself. This is not flexible and goes against the idea of creating reusable components.</li> </ul>"},{"location":"guide/dependency-injection/what-is-denpendency-injection/#4-complex-maintenance","title":"4. Complex Maintenance","text":"<ul> <li>As the application grows and more dependencies are added to the <code>Service</code> class, it becomes more difficult to manage.</li> <li>If every class is responsible for creating its own dependencies, the codebase becomes harder to maintain, leading to potential code duplication and tightly coupled components.</li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/","title":"Bean collection","text":"<p>The <code>BeanCollection</code> class in PySpring is designed to help integrate third-party code, especially when developers cannot modify the code directly. Below is a breakdown of its key features and functionality.</p>"},{"location":"guide/entities-in-framework/bean-collection/#purpose-and-key-features","title":"Purpose and Key Features","text":"<ul> <li> <p>Bean Management: The <code>BeanCollection</code> helps organize and manage a collection of beans (components) within a class. It provides a way to access and control these beans efficiently.</p> </li> <li> <p>Scanning for Beans: The <code>scan_beans()</code> method scans the current class for methods that create beans. These methods are identified by their names, which by default start with the identifier <code>create</code> (e.g., <code>createMyBean</code>).</p> </li> <li> <p>Bean Creation: Beans are created using methods whose return types are annotated. The return type of a bean creation method indicates the type of the bean being created.</p> </li> <li> <p>BeanView: Each bean is represented by a <code>BeanView</code> object, which holds:</p> <ul> <li>The bean itself</li> <li>The bean's name</li> <li>The bean creation function</li> <li>A validation method (<code>is_valid_bean()</code>) to check if the bean's name matches the name of the class it returns.</li> <li>Error Handling: Common errors are handled through exceptions, such as:<ul> <li><code>BeanConflictError</code>: Raised when a bean with the same name already exists.</li> <li><code>InvalidBeanError</code>: Raised when the bean's name doesn't match the class name.</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#properties-integration","title":"Properties Integration","text":"<p><code>BeanCollection</code> can also work with properties, which are loaded before the beans are created. This is a key aspect of how <code>BeanCollection</code> integrates with the broader PySpring framework.</p>"},{"location":"guide/entities-in-framework/bean-collection/#how-properties-interact-with-beancollection","title":"How Properties Interact with BeanCollection:","text":"<ul> <li> <p>Properties Loading:     PySpring loads properties from a designated properties file using the <code>Properties</code> class and <code>_PropertiesLoader</code>. This happens before the initialization of the Inversion of Control (IoC) container.</p> </li> <li> <p>Accessing Properties:     Once loaded, properties are accessible via the <code>get_properties()</code> method in the <code>ApplicationContext</code>. The properties are stored in the <code>singleton_properties_instance_container</code>.</p> </li> <li> <p>Dependency Injection:     PySpring's dependency injection mechanism ensures that any required properties are injected into a bean before it is created. This is done by inspecting the type annotations of the bean creation function.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#how-it-works","title":"How it Works:","text":"<ol> <li> <p>Configuration:     The application is configured to load properties from a specific file as defined in <code>app-config.json</code>.</p> </li> <li> <p>Loading Properties:     During initialization, <code>PySpringApplication</code> uses the <code>_PropertiesLoader</code> to load properties into a dictionary. The keys in the dictionary match the keys defined in the <code>Properties</code> class. The <code>load_properties()</code> method of <code>ApplicationContext</code> then makes these properties available.</p> </li> <li> <p>Bean Creation with Properties:     When a bean is created via a method in <code>BeanCollection</code>, PySpring checks for any dependencies, including properties. If a property is declared as a dependency, it will be injected into the bean before the bean is created.</p> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#example","title":"Example:","text":"<p>Suppose you have a properties class and a bean collection: <pre><code>from py_spring_core import Properties, BeanCollection\n\nclass MyProperties(Properties):\n    __key__ = \"my_properties\"\n    my_config_value: str\n\nclass MyBeanCollection(BeanCollection):\n    properties: MyProperties\n    @classmethod\n    def createMyBean(cls) -&gt; MyBean:\n        return MyBean(cls.properties.my_config_value)\n\nclass MyBean:\n    def __init__(self, config_value: str):\n        self.config_value = config_value`\n</code></pre> In this example:</p> <ul> <li><code>MyBeanCollection</code> creates a <code>MyBean</code> instance and depends on <code>MyProperties</code> to fetch a configuration value.</li> <li>When the <code>ApplicationContext</code> initializes the bean, it first loads the properties from the properties file and injects the <code>MyProperties</code> instance into the <code>createMyBean</code> method.</li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#how-beancollection-works","title":"How BeanCollection Works","text":"<ol> <li> <p>Identifying Bean Creation Functions:     The <code>scan_beans()</code> method identifies bean creation methods by checking if their names start with a specific identifier, which is <code>create</code> by default. For example, a method named <code>createMyBean</code> would be recognized as a bean creation method.</p> </li> <li> <p>Creating <code>BeanView</code> Instances:     For each method found, <code>scan_beans()</code> creates a <code>BeanView</code> instance. This object stores information about the bean, such as the creation function and the bean's class type.</p> </li> <li> <p>Bean Validation:     The <code>is_valid_bean()</code> method within <code>BeanView</code> checks whether the name of the bean matches the name of the class it is supposed to create. For instance, if a method is annotated to return an object of type <code>MyBean</code>, the bean's name must also be <code>MyBean</code>.</p> </li> <li> <p>Dependency Injection:     While <code>BeanCollection</code> is responsible for creating bean instances, dependency injection ensures that any required dependencies (including properties) are automatically injected into the beans.</p> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#integration-with-pyspring","title":"Integration with PySpring","text":"<ul> <li> <p>Registration:     <code>BeanCollection</code> classes are registered within the <code>ApplicationContext</code>. This allows PySpring to manage and inject these beans into other components of the application.</p> </li> <li> <p>Singleton Management:     Beans created by <code>BeanCollection</code> are treated as singletons by the <code>ApplicationContext</code>, meaning that only one instance of each bean is created and reused.</p> </li> <li> <p>Usage:     Beans managed by <code>BeanCollection</code> can be accessed through the <code>ApplicationContext</code> using the <code>get_bean()</code> method.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#benefits-of-using-beancollection","title":"Benefits of Using BeanCollection","text":"<ul> <li> <p>Loose Coupling:     The application code does not need to know how third-party objects are created, promoting separation of concerns and flexibility.</p> </li> <li> <p>Centralized Management:     Beans are managed in one central location, making it easier to find and maintain them.</p> </li> <li> <p>Simplified Integration:     <code>BeanCollection</code> provides a standardized approach to integrating third-party or external code without needing to modify it.</p> </li> <li> <p>Dependency Injection:     Beans can take advantage of PySpring's dependency injection, allowing them to access other registered components, controllers, or beans.</p> </li> <li> <p>Properties Support:     <code>BeanCollection</code> can load properties before bean creation, making it possible to configure beans dynamically using values from external properties files.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#beans-interacting-with-other-components","title":"Beans Interacting with Other Components","text":"<p>Beans created within a <code>BeanCollection</code> can interact with other components and properties defined within the project, not just the properties used during their initial creation. PySpring's dependency injection mechanism allows these beans to access other registered entities (components, beans, and properties) after they are instantiated.</p>"},{"location":"guide/entities-in-framework/bean-collection/#how-this-interaction-works","title":"How This Interaction Works:","text":"<ul> <li> <p>Dependency Injection:     When a bean is created, PySpring examines the type hints of the bean creation method, as well as the class definitions of other components, for type annotations. It uses these annotations to inject the necessary dependencies into the bean, including other beans, properties, and components.</p> </li> <li> <p>Component Interaction:     In your example, <code>ExampleService</code> has type hints for <code>ExampleProperties</code> and <code>MyBean</code>. When <code>ExampleService</code> is instantiated, PySpring uses dependency injection to inject the correct instances of these dependencies. Additionally, <code>AnotherExampleService</code> depends on <code>ExampleService</code>, which allows it to access properties via <code>ExampleService</code>.</p> </li> <li> <p>Lifecycle Methods:     Components like <code>ExampleService</code> and <code>AnotherExampleService</code> have lifecycle methods (<code>post_construct</code> and <code>pre_destroy</code>) that PySpring automatically calls. The <code>post_construct</code> method is executed after a component is initialized, meaning all its dependencies have been injected. At this point, the component can begin using the injected objects and properties.</p> </li> </ul> <pre><code>class MyProperties(Properties):\n    key = \"my_properties\"\n    my_config_value: str\n\n\nclass MyBeanCollection(BeanCollection):\n    properties: MyProperties\n\n    @classmethod\n    def createMyBean(cls) -&gt; MyBean:\n        return MyBean(cls.properties.my_config_value)\n\n\nclass MyBean:\n    def __init__(self, config_value: str):\n        self.config_value = config_value\n\n\nclass ExampleProperties(Properties):\n    key = \"example\"\n    value: str\n\n\nclass ExampleService(Component):\n    example_properties: ExampleProperties\n    my_bean: MyBean\n\n    def post_construct(self) -&gt; None:\n        logger.info(f\"Example value: {self.example_properties.value}\")\n\n    def pre_destroy(self) -&gt; None:\n        logger.info(\"Pre destroy method called\")\n\n\nclass AnotherExampleService(Component):\n    example_service: ExampleService\n\n    def post_construct(self) -&gt; None:\n        logger.info(\"AnotherExampleService post construct called\")\n        logger.info(f\"Example value: {self.example_service.example_properties.value}\")\n</code></pre>"},{"location":"guide/entities-in-framework/bean-collection/#how-it-works-in-this-example","title":"How It Works in This Example:","text":"<ol> <li> <p>Properties Loading:     The application loads properties for <code>MyProperties</code> and <code>ExampleProperties</code> from the properties file.</p> </li> <li> <p>Bean Creation:     <code>MyBeanCollection</code> creates an instance of <code>MyBean</code>, injecting <code>MyProperties</code> during its creation.</p> </li> <li> <p>Component Instantiation:     PySpring initializes <code>ExampleService</code> and <code>AnotherExampleService</code>, injecting dependencies via type annotations.</p> </li> <li>Dependency Injection:<ul> <li><code>ExampleService</code> receives an instance of <code>ExampleProperties</code> and an instance of <code>MyBean</code>.</li> <li><code>AnotherExampleService</code> receives an instance of <code>ExampleService</code>.</li> </ul> </li> <li>Lifecycle Hook:<ul> <li>The <code>post_construct</code> method in <code>ExampleService</code> logs the value of <code>example_properties.value</code>, demonstrating that injected properties are available. It also shows that the injected <code>MyBean</code> is accessible.</li> <li>The <code>post_construct</code> method in <code>AnotherExampleService</code> logs the value of the same <code>example_properties.value</code> via <code>example_service</code>, demonstrating access to an injected component's properties.</li> </ul> </li> </ol>"},{"location":"guide/entities-in-framework/bean-collection/#key-takeaways","title":"Key Takeaways:","text":"<ul> <li> <p>Beans Interact with Components:     Beans created by a <code>BeanCollection</code> can interact with any component registered within the application context. This is because all these classes (beans, components, and controllers) are managed by the application context.</p> </li> <li> <p>Properties Sharing:     Properties loaded from a properties file are not only used for bean creation but can also be injected into components. This enables dynamic configuration of the application.</p> </li> <li> <p>Dependency IoC Container:     PySpring builds a dependency IoC container for all registered entities. This allows the framework to inject objects into other entities (properties, beans, components) that depend on them.</p> </li> <li> <p>Flexibility:     This approach provides a flexible architecture where components and beans can depend on each other, allowing the creation of modular and interconnected applications.</p> </li> </ul>"},{"location":"guide/entities-in-framework/bean-collection/#summary","title":"Summary","text":"<p>The <code>BeanCollection</code> class provides a structured method to integrate external code into a PySpring application by treating them as managed beans. This approach enhances modularity, maintainability, and reduces tight coupling with third-party code. Additionally, it supports properties loading and dependency injection, allowing for more flexible and configurable bean creation.</p>"},{"location":"guide/entities-in-framework/component/","title":"Component","text":"<p>The <code>Component</code> class in PySpring serves as the foundational building block for creating modular, reusable functionalities. It supports lifecycle management, dependency injection, and property configuration, making it an essential entity in the PySpring framework.</p>"},{"location":"guide/entities-in-framework/component/#overview","title":"Overview","text":"<p>The <code>Component</code> class encapsulates specific functionalities and enables seamless integration with the PySpring application context. It is highly configurable, allowing developers to define scope, inject dependencies, and manage lifecycle hooks.</p>"},{"location":"guide/entities-in-framework/component/#features","title":"Features","text":"<ol> <li> <p>Reusability and Modularity    Components are designed to be reusable and modular, encapsulating specific functionalities that can be leveraged across the application.</p> </li> <li> <p>Scope Management     The scope determines whether the component instance is shared (<code>Singleton</code>) or created a new each time (<code>Prototype</code>),  which can be configured using the <code>ComponentScope</code> enum.  </p> <ul> <li><code>Singleton</code>: Single shared instance throughout the application.  </li> <li><code>Prototype</code>: A new instance is created per request.</li> </ul> </li> <li> <p>Lifecycle Hooks    Components provide hooks for initialization and destruction:  </p> <ul> <li><code>post_construct()</code>: Invoked after the component is initialized.  </li> <li><code>pre_destroy()</code>: Invoked before the component is destroyed.</li> </ul> </li> <li> <p>Dependency Injection    Components can be declare as dependencies for being injected to other components by the PySpring framework.</p> </li> <li> <p>Properties Injection    Properties from configuration files can be injected into components to simplify configuration management.</p> </li> </ol>"},{"location":"guide/entities-in-framework/component/#configuration","title":"Configuration","text":""},{"location":"guide/entities-in-framework/component/#nested-config-class","title":"Nested <code>Config</code> Class","text":"<p>The <code>Component</code> class includes a nested <code>Config</code> class to define configuration options, such as:  </p> <ul> <li>Allowed scope (<code>Singleton</code> or <code>Prototype</code>).</li> </ul>"},{"location":"guide/entities-in-framework/component/#methods","title":"Methods","text":""},{"location":"guide/entities-in-framework/component/#lifecycle-methods","title":"Lifecycle Methods","text":"<ul> <li><code>post_construct()</code>:     Called after initialization to set up the component. Subclasses can override this method.</li> <li><code>pre_destroy()</code>:     Called before destruction for cleanup. Subclasses can override this method.</li> <li><code>finish_initialization_cycle()</code>:     Invokes <code>post_construct()</code> and finalizes initialization.</li> <li><code>finish_destruction_cycle()</code>:     Invokes <code>pre_destroy()</code> and finalizes destruction.</li> </ul>"},{"location":"guide/entities-in-framework/component/#scope-management","title":"Scope Management","text":"<ul> <li><code>get_scope()</code>:   Returns the current scope of the component (<code>Singleton</code> or <code>Prototype</code>).</li> <li><code>set_scope(scope: ComponentScope)</code>:   Sets the scope of the component.</li> </ul>"},{"location":"guide/entities-in-framework/component/#usage-example","title":"Usage Example","text":"<pre><code>from py_spring_core import Component, ComponentScope\n\nclass MyComponent(Component):\n    class Config:\n        scope = ComponentScope.Singleton\n\n    def post_construct(self):\n        print(\"Component initialized.\")\n\n    def pre_destroy(self):\n        print(\"Component about to be destroyed.\")\n</code></pre>"},{"location":"guide/entities-in-framework/properties/","title":"Properties","text":"<p>The <code>Properties</code> class in PySpring provides a way to manage application-specific configurations. It allows you to load properties from a file and inject them into components.</p>"},{"location":"guide/entities-in-framework/properties/#key-features","title":"Key Features","text":"<ul> <li>Properties Registration: Properties classes are registered within the <code>ApplicationContext</code>, similar to components, controllers, and bean collections.</li> <li>Configuration Management:  <code>Properties</code> classes provide a structured way to manage application settings. They are loaded from a properties file, typically in JSON or YAML format.</li> <li>Unique Identifiers: Each <code>Properties</code> class has a unique key (<code>__key__</code>) that is used to identify it within the application. This key must be set as a class-level attribute in your <code>Properties</code> subclass.</li> <li>Automatic Loading and Injection: PySpring automatically loads properties during the application initialization process and injects them into components where they are needed.</li> <li>File Format Support: Properties can be loaded from JSON or YAML files. The <code>_PropertiesLoader</code> class handles the parsing of these files.</li> <li>Validation: The <code>Properties</code> class uses <code>Pydantic</code> for data validation. This ensures that the loaded properties conform to the expected schema.</li> <li>Singleton Scope: Properties are typically loaded as singletons within the application context and are shared across the application.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-to-define-properties","title":"How to Define Properties","text":"<p>To define your properties, you need to create a class that inherits from <code>Properties</code> and set the <code>__key__</code> class variable . This key must be a unique string that will be used to identify this <code>Properties</code> class.</p> <pre><code>from py_spring_core import Properties\nfrom pydantic import Field\n\nclass AppConfigProperties(Properties):\n    __key__ = \"app_config\" # Unique key for this properties class\n    app_name: str\n    version: str = Field(default=\"0.1.0\")\n    log_level: str = \"INFO\"\n</code></pre> <p>In the above example:</p> <ul> <li><code>AppConfigProperties</code> inherits from the base <code>Properties</code> class.</li> <li><code>__key__</code> is set to <code>\"app_config\"</code>, which is used to identify this specific set of properties.</li> <li><code>app_name</code>, <code>version</code>, and <code>log_level</code> are properties defined using Pydantic's field syntax.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#how-properties-are-loaded","title":"How Properties are Loaded","text":"<p>The <code>_PropertiesLoader</code> class is used to load properties from a file.</p> <ol> <li>During application startup, the <code>PySpringApplication</code> initializes an <code>ApplicationContext</code> that loads the properties.</li> <li>The application scans for all classes that inherit from <code>Properties</code>.</li> <li>The properties file path is defined in the application config (e.g., <code>./application-properties.json</code> or <code>./application-properties.yaml</code>).</li> <li>The loader attempts to read and parse the file based on its extension (<code>.json</code>, <code>.yaml</code>, or <code>.yml</code>).</li> <li>The loader validates the properties against the classes that inherit from <code>Properties</code>, ensuring the keys match what has been defined in the application, and raises an error if validation fails.</li> <li>Once loaded, the properties are stored in the <code>ApplicationContext</code> and are accessible for dependency injection.</li> </ol>"},{"location":"guide/entities-in-framework/properties/#how-to-use-properties","title":"How to Use Properties","text":""},{"location":"guide/entities-in-framework/properties/#dependency-injection","title":"Dependency Injection","text":"<p>Once properties are loaded, you can inject them into your components using type annotations.</p> <p><pre><code>from py_spring_core import Component, Properties\nfrom .app_config_properties import AppConfigProperties\n\nclass MyComponent(Component):\n    app_config: AppConfigProperties\n\n    def post_construct(self):\n        print(f\"App Name: {self.app_config.app_name}\")\n        print(f\"Log Level: {self.app_config.log_level}\")`\n</code></pre> In this example:</p> <ul> <li>The <code>MyComponent</code> class has a type annotation <code>app_config: AppConfigProperties</code>, where <code>AppConfigProperties</code> is the properties class defined above.</li> <li>The application context automatically injects an instance of <code>AppConfigProperties</code> into the <code>app_config</code> attribute of the <code>MyComponent</code> instance.</li> <li>The properties can then be accessed within the <code>MyComponent</code>'s methods.</li> </ul>"},{"location":"guide/entities-in-framework/properties/#accessing-properties-directly","title":"Accessing Properties Directly","text":"<p>You can also access properties directly from the <code>_PropertiesLoader</code> if needed. Note, this is typically not necessary if you are using dependency injection.</p> <pre><code>from py_spring_core.core.entities.properties.properties_loader import _PropertiesLoader\n\napp_config = _PropertiesLoader.get_properties(\"app_config\")\n\nif app_config:\n    print(f\"Direct access: App Name: {app_config.app_name}\")`\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#configuration-file-examples","title":"Configuration File Examples","text":""},{"location":"guide/entities-in-framework/properties/#json","title":"JSON","text":"<p>A JSON properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass.</p> <pre><code>{\n  \"app_config\": {\n    \"app_name\": \"My Cool App\",\n    \"version\": \"1.2.3\",\n    \"log_level\": \"DEBUG\"\n  }\n}\n</code></pre>"},{"location":"guide/entities-in-framework/properties/#yaml","title":"YAML","text":"<p>A YAML properties file might look like this. The key <code>app_config</code> must match the key defined in the <code>Properties</code> subclass. <pre><code>app_config:\n  app_name: My Cool App\n  version: 1.2.3\n  log_level: DEBUG`\n</code></pre></p>"},{"location":"guide/entities-in-framework/properties/#important-considerations","title":"Important Considerations","text":"<ul> <li>Key Uniqueness: Ensure that each <code>Properties</code> class has a unique <code>__key__</code> to avoid conflicts.</li> <li>File Path: The properties file path must be correctly configured in the application's configuration file.</li> <li>File Format: PySpring supports both JSON and YAML formats for properties files.</li> <li>Validation: Ensure that your properties files match the structure defined in your <code>Properties</code> classes. Pydantic will enforce data types and raise errors if there are mismatches.</li> <li>Dependency Injection: For loose coupling, use dependency injection to make your properties available to components, which is typically preferred over directly accessing properties from <code>_PropertiesLoader</code>.</li> <li>Error Handling: Be aware of the exceptions that can be raised during properties loading, such as <code>InvalidPropertiesKeyError</code>, and <code>TypeError</code> if the properties are not found or are not properly configured.</li> </ul> <p>By using the <code>Properties</code> class, you can effectively manage your application's configurations in a structured and maintainable way.</p>"},{"location":"guide/entities-in-framework/rest-controller/","title":"RestController","text":"<p>The <code>RestController</code> class in PySpring serves as a base class for building RESTful API controllers. It provides a structured way to define API endpoints, handle HTTP requests, and manage middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#key-features","title":"Key Features","text":"<ol> <li>Base Class: Acts as a base class that should be extended for creating specific controllers.</li> <li>Routing: Provides a mechanism to register routes using FastAPI's routing capabilities.</li> <li>Middleware Support: Allows registration of middleware for pre- and post-request processing.</li> <li>FastAPI Integration: Leverages FastAPI's features for building high-performance APIs.</li> <li>Configuration: Supports configuration of the base URL prefix for controller routes.</li> <li>Automatic Registration: Automatically integrates controllers with the application context and FastAPI during initialization.</li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#how-to-define-a-restcontroller","title":"How to Define a RestController","text":""},{"location":"guide/entities-in-framework/rest-controller/#create-a-controller-class","title":"Create a Controller Class","text":"<p>Extend the <code>RestController</code> class and override the <code>register_routes()</code> method to define routes. Optionally, override <code>register_middlewares()</code> to add middleware.</p>"},{"location":"guide/entities-in-framework/rest-controller/#example","title":"Example:","text":"<pre><code>from py_spring_core import RestController\nfrom fastapi import HTTPException\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\nclass MyController(RestController):\n    class Config:\n        prefix = \"/api/items\"  # Base URL prefix for this controller\n\n    def register_routes(self):\n        @self.router.get(\"/\")\n        def read_items():\n            return {\"message\": \"List of items\"}\n\n        @self.router.get(\"/{item_id}\")\n        def read_item(item_id: int):\n            return {\"message\": f\"Details for item {item_id}\"}\n\n        @self.router.post(\"/\", status_code=201)\n        def create_item(item: Item):\n            return item\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#key-points","title":"Key Points:","text":"<ul> <li>Use the <code>Config</code> inner class to set the route prefix.</li> <li>Define routes using the <code>@self.router</code> decorator.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#automatic-registration-process","title":"Automatic Registration Process","text":"<ol> <li>During application startup, PySpring scans for classes inheriting from <code>RestController</code>.</li> <li>The <code>_handle_register_rest_controller()</code> method:<ul> <li>Registers the controller with the application context.</li> <li>Initializes an <code>APIRouter</code> instance.</li> <li>Calls <code>register_routes()</code> to add routes.</li> <li>Includes the controller's router in the main FastAPI application.</li> <li>Calls <code>register_middlewares()</code> for middleware registration.</li> </ul> </li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#defining-routes","title":"Defining Routes","text":"<p>Use <code>@self.router</code> decorators to define API endpoints inside <code>register_routes()</code>:</p> <pre><code>@self.router.get(\"/\")\ndef read_items():\n    return {\"message\": \"List of items\"}\n\n@self.router.post(\"/\", status_code=201)\ndef create_item(item: Item):\n    return item\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#example_1","title":"Example:","text":"<ul> <li><code>GET /</code> maps to the <code>read_items</code> method.</li> <li><code>POST /</code> maps to the <code>create_item</code> method.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#fastapi-features","title":"FastAPI Features:","text":"<ul> <li>Dependency Injection</li> <li>Request body handling</li> <li>Path parameter parsing</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#defining-middlewares","title":"Defining Middlewares","text":"<p>Override <code>register_middlewares()</code> to add middleware. Use <code>app.middleware()</code> to define custom middleware functions.</p>"},{"location":"guide/entities-in-framework/rest-controller/#example_2","title":"Example:","text":"<pre><code>def register_middlewares(self):\n    @self.app.middleware(\"http\")\n    async def add_process_time_header(request, call_next):\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n        response.headers[\"X-Process-Time\"] = str(process_time)\n        return response\n</code></pre>"},{"location":"guide/entities-in-framework/rest-controller/#common-middleware-use-cases","title":"Common Middleware Use Cases:","text":"<ul> <li>Authentication</li> <li>Authorization</li> <li>Logging</li> <li>Performance metrics</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#accessing-fastapi-components","title":"Accessing FastAPI Components","text":"<ul> <li><code>self.app</code>: The main FastAPI application instance.</li> <li><code>self.router</code>: The APIRouter instance for the controller.</li> </ul>"},{"location":"guide/entities-in-framework/rest-controller/#important-considerations","title":"Important Considerations","text":"<ol> <li>Class Configuration: Use the <code>Config</code> class to define the URL prefix.</li> <li>Route Registration: Ensure all routes are defined in <code>register_routes()</code> using <code>@self.router</code>.</li> <li>Middleware Registration: Add middleware in <code>register_middlewares()</code> using <code>app.middleware()</code>.</li> <li>Dependency Injection: In this class, you can leverage both PySpring's and FastAPI's dependency injection systems to manage dependencies efficiently.</li> <li>Error Handling: Use <code>HTTPException</code> for proper error responses and integrate with PySpring's error handling mechanisms.</li> <li>Code Organization: Keep controllers focused on request handling and delegate business logic to services or components.</li> </ol>"},{"location":"guide/entities-in-framework/rest-controller/#summary","title":"Summary","text":"<p>The <code>RestController</code> class helps build well-structured, maintainable, and scalable RESTful APIs in PySpring. By utilizing its features like routing, middleware support, and integration with FastAPI, developers can focus on creating efficient APIs while maintaining code clarity and modularity.</p>"}]}